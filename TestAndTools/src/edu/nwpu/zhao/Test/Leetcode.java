package edu.nwpu.zhao.Test;

import java.io.IOException;
import java.util.*;

/**
 * @author:weilongzhao
 * @time:2021/7/15 21:38
 */
class Student{
    String name;
    int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Student(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Strudent{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
class TreeNode {
    public int value;
    public TreeNode left;
    public TreeNode right;
    public String val;

    public TreeNode(int value, TreeNode left, TreeNode right) {
        this.value = value;
        this.left = left;
        this.right = right;
    }

    public TreeNode() {
    }
    public TreeNode(int val) {
        this.value = val;
    }
}
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;
    public Node(int val){
        this.val = val;
    }
}
class ListNode{
    int val;
    ListNode next;
    public ListNode(int val){
        this.val = val;
    }
}

public class Leetcode {
    private static int nums = 0;
    private static int MOD = 100000007;

    public static void main(String[] args) throws IOException {
        int[] arr = {1, 7, 3, 5, 6};
        //System.out.println(arrayCenterIndex(arr));
        int[] array = {-9, -8, 0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
        //System.out.println(deleteDuplicatedElements(array));;
        //System.out.println((int)newton(1,10));
        //System.out.println(maxResultOfThereMultiple(array));
        //      int [] pos = twoNumsEqualsTarget(arr,13);
//        for (int i = 0; i < pos.length; i++) {
//            System.out.print(pos[i]+" ");
//        }
        //System.out.println(Fibonacci(10));
//        TreeNode root = generate();
//        System.out.println(minDeep2(root));
//        System.out.println(minDeep(root));
        //int []bills = new int[]{5,10,5,10,20};
        //System.out.println(isCharge(bills));
        //int [][]isConnected;
        //isConnected = new int[][]{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
        //System.out.println(findCircleNum(isConnected));
        //System.out.println(champagneTower(100000009,33,17));
        //String []borad = new String[]{"OOXXOXXX","XXXOXOXO","OXOXXXOO","XOXOXXXX","OXOOXOOO","XOOOOOOO","OXXXOOOX","XOXOOXXX"};
        //borad = ["OOX","XXO","OXO"];
        //System.out.println(tictactoe(borad));
        //int []nums = new int[]{114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240};
        //System.out.println(robRecurve(nums,nums.length-1));
        //TreeNode root = generate();
        //midOrder(root);
        //int []result = dfs(root);
        //System.out.println(Math.max(result[0],result[1]));
//        int[] nums = new int[]{3,4,5,1,3,-1,1};
//        String [] strArray = arrayToString(nums);
//        System.out.println(strArray);
//        TreeNode root = createTree(strArray);
//        midOrder(root);
        //Deque<Integer> queue = new ArrayDeque();
//        Map map = new HashMap<String,Integer>();
//        map.put(null,null);
//        map.put("1",1);
//        List<String> list = new ArrayList();
//        list.add("S");
//        list.add(null);
//        System.out.println(list.get((Integer) map.get("1")));
        //System.out.println(list);
//        int[][] rooms = new int[][]{{2,2},{1,2},{3,2}};
//        Arrays.sort(rooms, new Comparator<int[]>() {
//            @Override
//            public int compare(int[] o1, int[] o2) {
//                return o1[0]-o2[0];
//            }
//        });
//        for (int i = 0; i < 3; i++) {
//            for (int j = 0; j < 2; j++) {
//                //System.out.print(rooms[i][j]+" ");
//            }
//            //System.out.println();
//        }

//        List<String> list = new ArrayList();
//        list.add("1");
//        list.add("2");
//        list.add("3");

        //int []arr_tmp = binary_Search(list,5);
        //list.remove(0);
        //System.out.println(String.join("",  list));

//        int [][] rooms = {{1,4},{2,3},{3,5},{4,1},{5,2}};
//        int [][] queries = {{2,3},{2,4},{2,5}};
//        int [] arr_tmp = closestRoom(rooms,queries);
//        for (int i = 0; i < arr_tmp.length; i++) {
//            System.out.print(arr_tmp[i]+" ");
//        }
        //System.out.println(Runtime.getRuntime().totalMemory());
//        List<String> parenthesis = generateParenthesis(3);
//        for (int i = 0; i < parenthesis.size(); i++) {
//            System.out.println(parenthesis.get(i));
//        }
//        StringBuilder sb = new StringBuilder();
//        sb.toString();
//        Map<String,List<String>> map = new HashMap();
//        groupAnagrams(new String[]{"eat", "tea", "tan", "ate", "nat", "bat"});
//        List<List<Integer>> res = permute(new int[]{1,2,3});
//        for (int i = 0; i < res.size(); i++) {
//            for (int j = 0; j < res.get(i).size(); j++) {
//                System.out.print(res.get(i).get(j)+" ");
//            }
//            System.out.println();
//        }
        //System.out.println(maxSubArray(new int[]{-2,1,-3,4,-1,2,1,-5,4}));
//        int [][] arr1 = new int[][]{{-2,1},{-3,4},{-1,2}};
//        int [][] res = merge(arr1);
//        for (int i = 0; i < res.length; i++) {
//            for (int j = 0; j < res[i].length; j++) {
//                System.out.print(res[i][j]+" ");
//            }
//            System.out.println();
        // }
//        int [][]res = insert(new int[][]{},new int[]{2,5});
//        for (int i = 0; i < res.length; i++) {
//            for (int j = 0; j < res[i].length; j++) {
//                System.out.print(res[i][j]+" ");
//            }
//            System.out.println();
//        }
//        Map<Integer,Boolean>map = new HashMap<>();
//        //map.replace(map.get(i),true);
//        Queue<Integer>q = new LinkedList<>();
//       int []arrtmp = new int[]{};
//        System.out.println(arrtmp.length);
//        Set<List<Integer>>set = new HashSet<>();
//        set.add(null);
//        List<List<Integer>>listTmp = new ArrayList<>(set);
//        Set<List<Integer>> hashSet = new HashSet<>(set);
//        List<List<Integer>> resList = subsetsWithDup(new int[]{1,2,2});
//        for(List<Integer>l:resList){
//            for(int i:l){
//                System.out.print(i+", ");
//            }
//            System.out.println();
//        }
//        Queue<Integer>q = new LinkedList<>();
//        Map<Integer,Integer>map = new HashMap<>();
//        Iterator<Map.Entry<Integer,Integer>> it = map.entrySet().iterator();
//        Map.Entry en = it.next();
//        int maxCurrence = (int) en.getKey();
//        int maxNums = (int) en.getValue();
//        while(it.hasNext()){
//            en = it.next();
//            if(maxNums<(int)en.getValue()){
//                maxCurrence = (int) en.getKey();
//            }
//        }
//        System.out.println(majorityElement(new int[]{12,52,12,70,12,61,12,12,50,
//                72,82,12,11,25,28,43,40,12,12,53,12,12,98,12,12,92,81,2,12,15,40,12,12,9,12,31,12,12,12,12,77,12,12,50,
//                12,12,12,93,41,92,12,12,12,12,12,12,12,12,12,37,48,14,12,70,82,12,80,12,12,12,12,56,30,12,8,12,50,12,20,
//                12,21,97,12,42,12,10,12,38,73,15,9,11,79,12,12,28,51,12,15,12}));
        //System.out.println(numIslands(new char[][]{{'1','1','1'}, {'0', '1', '0'}, {'1', '1', '1'}}));
        //System.out.println(minSubArrayLen(7,new int[]{2,3,1,2,4,3}));
//        System.out.println(countArrangement(3));
//        Set set = new HashSet();
//        set.size()
        //System.out.println(findPaths(8, 7, 16, 1, 5));
        //System.out.println(checkRecord(2));
        int[] arr2 = new int[]{5731, 8166, 1064, 8508, 6255, 1605, -2106, -3534, 4018, 9220, 5121, 613, -5503, 543,
                //4440, 9140, -6495, 9029, -3536, -2242, 1393, 7793, 4225, -1181, -1161, -372, 5665, 3407, -8827, -1299, 241, 793,
                //-5001, 4923, 4020, 6537, -7711, 260, 1301, -7252, -3866, -3865, 9201, 8442, 4662, 2432, -7055, -750, -5089, -129,
                //-9148, -1476, 7098, 3646, -8668, -1741, -6016, -4131, -2320, -4543, 1018, -7365, 7914, 4915, 7594, -4997, -330,
                //3948, -6611, 8601, -7092, -9964, 4283, -5156, 9124, -744, 4596, -7322, 6075, 3443, 1672, -2428, 790, -6368, -3068,
                //-6946, -4902, 1951, 7109, -6488, 843, 8872, 75, 2448, 8804, 3924, 5859, 6686, -6585, -1749, -9378, 4803, -258, -19,
                5012, -8904, -8905, 2298, -5292, 7873, -755, 8218, -9564, -5025, 7323, -4934, 7880, -3547, 1477, -6833, -7526,
                -7233, 1175, -2314, -2840, -4516, 1842, -8536, 4574, -5905, -1872, -7474, -9153, 4497, 6380, -6716, -7831, -6277,
                256, 2515, 6042, 8056, -9053, 1301, 913, -8816, -3162, 9288, 3367, -59, -1370, 1985, 1243, -5848, -3403, -5471,
                8135, 4518, -5000, -5808, 2333, 5385, 1637, 1252, 6699, -5738, 241, -7315, 6237, 4459, -7562, 9918, 2326, -3652,
                555, -2018, 8096, 6243, -2376, 1849, -9843, 9017, -7834, -7520, -7250, 4210, 2436, -768, 1327, 1070, -3890, -1226,
                6679, 1300, 1112, -9816, -4133, -8229, 8472, -6328, -7276, 9875, -9531, 9866, -4845, -765, 8891, 2258, 2326,
                -7246, 1116, -4068, 9688, 800, -6422, -6854, 7135, 3517, -1806, 5490, 1340, -4241, 5758, -6475, -3809, -3643,
                -6694, -7610, -6877, -3970, -9229, 7639, 3952, 9931, -4162, 788, 2948, 1885, 853, 2284, 3741, 4577, -5905, 4349,
                5919, 8437, -1475, 9651, 6234, -81, -1095, -700, 8102, 2808, -5954, 4098, 2825, -3630, 7949, 4121, 9406, -5426,
                -9863, 7103, 7803, 6022, -115, 9083, 2631, 1739, -3217, 6258, 7277, -5664, -1489, 4551, -6394, 8594, -5372, 5841,
                542, -6076, -5081, 2851, -2947, -736, 9841, 7585, -2342, -1909, -5735, -3343, 7750, -3670, 2272, 7968, -3045,
                -8229, -7269, -8542, 2101, -2601, 9575, 2148, 3646, 4703, -3749, -8888, 8694, -9693, 19, -7623, -4350, -7128,
                -1813, -613, -5244, -5875, 5942, 3876, 8159, -5977, -1280, 6357, -7530, 887, 845, 1232, -2043, -4218, 561, -8373,
                -6426, -4322, -4061, -3003, -8776, 4214, 1693, -4387, 4453, -9179, 5983, -7971, 240, 7355, -9743, 8354, 9679,
                -9763, 3327, -1294, -7309, 9921, -7072, -973, -8763, 9495, -695, -9228, -6230, 7884, -9856, 5666, -3354, -6681
                , 4040, 7426, -2796, 2781, 8816, 9290, -8561, -3620, -6307, 7215, -5443, 8116, -7230, 3313, -9550, 308, 9080,
                -1475, -3830, -2672, 3796, -3654, -3166, 6412, -9577, -2519, -8868, 249, 8082, 51, 1368, -3247, 4401, -5114,
                -2049, 482, 457, -6435, 2347, -1300, 1864, -7453, 1727, -1363, -2773, -1091, -5959, -703, -1789, 241, -4508,
                -9657, 9060, -3307, -7015, 8418, -6134, -1623, 8144, -6655, 5579, 370, 5979, 4608, 4487, -6133, -651, 4715, 6952,
                -6809, -3674, -1606, -6883, 4816, -4825, 7192, -7405, -5805, -9200, 294, 3265, 1333, 6345, -3235, -4010, 9129,
                558, 331, -3432, -3555, 3961, -1981, 1796, -3070, -8093, -5280, -5563, -2742, -753, -1521, -2536, -9763, -6425,
                2797, -2733, 8, 8550, 5062, -8488, -4118, 4816, -4762, -9291, -7635, -4277, 2214, 8467, 1395, 7421, 1248, -5222,
                -8928, -5450, -5884, 4995, -7217, -6036, 2782, 8214, -5789, 4417, -5254, -1379, -5086, 6580, 8739, 7248, -8565,
                5310, -2175, 9253, -3098, 2579, 8427, -154, -7202, 4664, -7500, 1565, -9142, 6167, -2641, 5721, 1309, -5400, 3841,
                -6030, 2098, 8033, -9857, 8288, 1717, -3841, 8677, -4140, -3960, 742, -380, -5509, -1715, 1590, -5848, -1394,
                6328, 8282, -5121, -3489, -8501, -2879, -6782, -5498, -6867, -9597, -7980, -7272, 7579, 8340, 1762, 1328, 1533,
                2665, 8785, 5056, 9483, -1788, 8429, -7175, -9137, 7462, -5102, -6821, 4490, 7645, -6657, 7581, 3613, 1187, 5047,
                7254, -4122, -8637, -7853, -1428, -9749, 1755, 8410, -42, -2227, 6895, 7049, 7221, 3651, 5292, 3319, 2427, 7625,
                -3568, 483, -9137, 6798, -7270, 6697, -4490, 4252, 6606, -5478, 9799, 5963, 5518, 3652, -5892, 8674, 4205, 1524,
                -5166, -6105, -797, 7747, -8865, 7260, -5955, -1823, -1698, 9345, -8849, 713, -694, -8355, -7858, 9812, -7978,
                9862, 732, -769, 8272, -7086, -9484, -4583, -5485, -9870, 6963, 7391, -2095, -4960, 6966, -393, 1207, 9607, -3778,
                -618, -7395, 3474, 1217, 3408, -9955, 5404, 8142, 2844, 6225, -5315, 2811, 4041, 3980, 6827, -8648, 5099, 9165,
                -6018, -7775, 9184, 3889, 9911, -7412, 4861, 83, -8313, -9954, 6172, 2382, 4848, -6771, 6316, -6563, 2182, 7454,
                3906, -3083, 8834, 9077, -4240, 3863, -5219, -3547, 9705, 4674, -502, 3384, 2670, -1178, 1498, -7239, -1593, 9900,
                5449, -8615, -6288, -6577, 2014, -5211, -9519, -4369, 7067, -5301, -9524, -4247, -2498, 6452, 5620, 4059, 993,
                -7552, -5140, -4917, 2338, 2044, -5490, 3227, -4363, -7731, 7198, -4133, 3616, -8107, -3683, 4178, 9559, 6747,
                3911, 5312, -5044, 6344, 8022, -9200, 3725, 7175, 7670, 1845, -8979, -5715, -6051, -8014, -5292, -1051, -1700,
                -9327, 6331, -8413, -4029, 9086, 6250, 998, -4386, 3987, -6460, 8180, -7824, -7418, 2887, 5771, -5241, -1208,
                -6045, 6220, -6313, 2012, -9634, 8884, -4377, 7825, 7118, -9521, 1050, -1973, 5884, -7594, -4015, 4340, 908,
                -1589, 4248, 7635, 1859, 9151, -3180, 2568, -1687, -394, -6759, 9407, 3568, -2347, 8188, -6563, 861, -3962, -3399,
                3771, 4835, 3672, 4162, -4373, -5501, 433, 4131, -4560, -2090, 2206, -5535, -9099, 2967, -4288, -6976, -4985,
                -7939, 6840, -7294, 8964, -9605, -1866, -8977, 5667, 6968, -985, 8008, -9704, -4907, 9908, 2012, -1560, 7842,
                -362, -7194, 1131, 3290, -3245, -4537, -7936, 4530, -1115, -6907, -5818, 5332, 3638, 6624, -4510, -8669, -7971,
                3118, -2404, 5066, -5630, -7289, 7933, -7215, 8272, 5017, -4390, 7460, 8510, -2352, -1786, 4799, 5727, 1581, -605,
                -3324, 318, -5530, -5764, -1231, -9988, -9832, -4895, -2455, 5520, -3860, -7626, -1160, 4462, 2376, 8718, -3816,
                -4123, 1162, -1802, 6451, 2093, -2196, -394, -3894, -4067, 5270, -5481, 5179, 8139, 9178, 1213, 283, -7479, 3645,
                -9771, 3784, -2327, 1283, 3502, -2697, 5628, 5492, 7612, 3150, -2324, -2058, -703, -5316, -4143, 9503, -2138, 5008,
                6743, 2422, 1194, 650, -5903, 9092, 2143, -3316, 5866, -6299, 4478, 604, -4859, 8359, -438, -6011, 4153, 8062, 7996,
                -4021, -4573, 7654, -8643, 5676, 32, -8195, -181, 3010, -3372, 9034, -3654, 8403, 6783, -3184, 8337, -2366, 7015,
                5301, 1739, 9822, 6875, -2202, 9342, 8237, -443, 7124, 952, 7204, 1653, 4249, -3987, 6898, -5359, -5376, 5175, 9366,
                5141, 5687, 6730, 2284, 6152, -2512, -5261, 4548, 1442, 2452, 3618, -3008, -7476, -185, 1272, -5897, -6864, 2283,
                -2263, -6408, -3812, -4933, 6096, -4263, -1053, -3454, 8644, 1057, -6751, 6345, -6967, 5009, 5536, 3165, -8958,
                -2144, -5395, -1639, 4886, -5501, 1073, 1439, 5315, -71, -6262, 6328, 1680, -8546, 6741, -699, 402, 8911, -8825,
                -7170, -6354, -1088, -2221, 9286, -2930, -7523, -4379, -5760, -2879, -6957, -7065, -3423, 391, -7377, -6413,
                2898, 4774, -5454, 9973, -9586, -2958, -2270, -9844, 8394, 9563, -81, 9096, -7734, -5658, 806, -2755, 7585, 1571,
                -903, -8261, 8153, 1466, -4855, 4668, 4956, 3713, -8592, 8105, -7873, -4182, 3233, 7394, 55, 1010, 6376, 3228, 1019,
                915, 7486, 3365, 1368, 6713, 8417, -5191, 3393, 1172, -7272, 5698, 564, -4284, 8492, -5040, -264, 3432, 6496, 9348,
                6524, -3330, 1702, -4551, 6128, -859, -9916, 591, 2798, 1881, -9873, 7555, 3053, 4301, 7826, 5484, 1928, -5235,
                -3874, -7843, 9298, -9684, 9121, 4301, 4329, -480, -636, -2498, -1953, -4667, -7438, -5404, -7183, -2541, 9426,
                3183, 8385, 470, 2200, 7537, -4753, 2765, -8618, -1763, 9100, -5036, -924, -4451, -9914, 9096, 3839, -3370, -6409,
                -3138, -8306, -9668, 2356, 3303, 9778, -5658, 8796, 3270, 7657, 9201, 6459, -7134, -67, -6007, 2843, -4339, 746,
                688, -7257, 8209, -3183, -6522, 6204, -2931, -1849, 779, -7112, -9344, 7153, 3493, -7792, -4275, -1911, -75, 2856,
                6242, -8249, 2817, 2419, -7304, -3651, -2533, -3470, -4361, 3477, -4538, 7088, -1372, -4666, 6587, 3728, 2770,
                3761, -4417, 7529, 7879, -4467, 6114, 9836, 5096, 6676, -4477, -219, 1582, 6433, 7898, 5747, -8259, 3928, -5690,
                -7339, -9616, 8217, -6781, -5732, -838, 9515, -8811, -7123, -2929, -5072, -1997, 8853, -4807, 9441, -36, 2020,
                -2236, -9471, 9062, -2108, 1743, -7253, 676, -3785, 7470, 316, -3357, 9738, -4485, -2326, 8450, 2428, 8944, -5840,
                -5256, -6836, -6626, -2691, -7954, -5994, 1592, -7736, -5970, -848, -9296, -1446, 3051, -5501, 7373, 7922, -5428,
                2342, 7594, 5665, 3850, 3068, 9895, -215, 8535, 6439, -7207, 2402, 1782, -5909, -7064, -8306, 7627, -9063, -8600,
                4077, -4736, 8728, 5480, 1436, -2114, 6436, 9112, -255, 3635, 3563, 9646, 5673, 6073, 2714, -2473, -5990, -4136,
                -8991, -7118, 8453, 9144, -4947, -2203, 3225, -9801, 20, -2783, -9711, -8974, -7100, -5975, 9107, 8936, -3323,
                6626, 6880, 3443, -8913, -4505, -2148, 3770, -557, 5074, -5191, -4143, -2827, -520, -2250, -6549, 8060, 8393,
                -4200, 4308, 4100, 4463, -6339, -8312, 7920, -9849, -1732, 933, -859, 6669, 5830, -3579, 3163, 8694, -1646, 8834,
                -7349, -7292, -6929, -553, 631, -1259, -7289, 7347, 5322, -7807, -6585, 3953, 7910, -3350, 4674, -2561, 73, 8064,
                -543, 7292, 913, -530, 9021, -3068, -9686, -9381, 2954, -3328, -7801, -6707, -2661, -1583, 1815, 3448, 3655, 8683,
                1040, 6931, 1161, 8425, 4374, 3632, 1404, 4601, 482, -3445, 883, -8667, -7690, 947, 7488, 5998, 3590, 2438, -2783,
                8879, -3585, -6016, -2162, 9985, -4778, -7629, -6555, -1055, -1356, 201, -3776, 9573, -1136, 9306, 9866, -3087,
                -2406, -8242, -5791, 4566, -5720, -6853, -6063, 4794, -8695, 3137, -2370, -5837, 9820, 8180, 5535, 7744, -6501,
                6867, -1620, 9194, 4184, 6436, -7982, -2208, 4386, 1611, 9621, 8808, -6881, -296, -2834, -7420, 7430, 405, -3501,
                3537, -3771, 5384, -3001, 1517, -6354, -8623, -6812, -825, 1276, 6174, -1942, 7705, 7650, -7832, 7264, -874, 9595,
                -892, 1523, -6297, -2094, 8633, -2101, 807, -2742, -5951, -1254, -402, -9886, 2289, -4596, -1438, -1092, 9418,
                -9242, -5444, 3466, -2099, -6106, -495, 3710, 504, -748, -7896, -6674, -1622, 3449, 1805, -5234, -344, 9194, 9766,
                1807, -9087, -6615, 5373, 2103, -9104, 3645, 8959, 1214, -929, -7218, -8740, 225, 9872, -9166, 7430, 5830, -3611,
                5962, -7775, 4074, 8559, 9353, 1521, 6711, -1509, -6548, -9259, -2404, -4524, -8524, 2942, 6429, -5184, 54, 1831,
                1703, -2776, -9460, 7461, 6785, 8834, 8967, 6560, 2180, 8871, -4243, -1803, 7757, 4642, -3394, 3013, 6595, 4750,
                8381, -8109, 1351, -6796, -3809, -7376, -5186, 8017, 8286, -1899, -7555, -9409, -8725, -371, -2679, -2670, -6024,
                6877, 8527, -9431, -1026, 2145, -257, 4209, -8148, 9447, 6693, -2432, 6496, 3726, -4539, 1078, 1570, 9456, -8668,
                7569, -8796, 3976, -8195, 962, -9648, 9903, -5843, 5193, -2642, -6754, 7137, 7397, 1012, 6064, -5107, -73, 2787,
                3760, 2875, -423, 9645, 6444, 8468, -6011, -6817, -6930, 1243, -5999, 5787, 7728, 7027, 5802, 7429, 8143, -9493,
                4500, -4319, -5217, -4416, -1841, -2612, -6789, 4010, -667, 6973, -265, 622, -7076, -1027, 802, -5338, -4213,
                -4819, 3214, 386, -7152, -7622, -5834, -2850, 3064, 797, -5044, -2535, -691, 1675, 47, -3007, -735, -1470, 136,
                1436, -8334, -6568, 7609, -6987, -9139, -1201, -9129, -3950, 9907, 6975, -4850, 4278, -5906, 7927, 4307, 7972,
                -5640, -8836, 7416, 163, -3083, 9279, 270, -9924, 1885, 6023, 3826, -1399, -989, 4493, -2601, -8166, 2551, 6950,
                -3250, -9300, 5223, 5997, 9799, -9388, 3650, 896, 8233, -4889, 7165, -8192, -1601, -8114, 2456, -2664, 418, -5211,
                -6371, -106, -8926, -3670, -3773, 2919, 6570, 8328, -3640, -633, -9119, 2435, 1099, -8059, 5999, 9011, 1155, -6841,
                7039, 9685, 2717, -2857, -8248, 1265, -3855, 8063, 8551, -6030, -5037, 5330, 9881, -3856, -959, -986, 3618, 7902,
                52, 3594, 3016, -7366, -5259, -5020, 7494, -1188, -6695, -4341, 1125, -1807, -7339, -6735, -6111, 2830, 5566,
                -7467, -3048, 1992, 9570, -7527, -61, 6599, 6305, 2363, -6867, -5764, 7318, 2414, 1385, -2016, 9935, 3062, 4695,
                2682, 1038, -8572, 5428, -4277, 3486, -5136, -5114, -8453, 6117, 3157, 9606, -1329, 6405, 8953, 5585, -3046, 6274,
                8384, 75, 4896, 9676, -5941, -3603, -3736, -6602, -8802, -1275, -5862, -2328, -2782, 7633, -7028, -9377, -3244,
                928, 8475, 6803, 147, -3386, 5457, -2726, 9380, -474, -266, -3431, -4126, -6468, 7787, -4620, -7092, -3350, 4006,
                8587, -9289, 614, 1146, 1962, -8137, -2466, -3391, -1016, -877, -4605, 7602, -4125, -8434, -1416, -8979, -1529,
                -425, 7604, -620, -8157, 9593, -5100, 6555, -6896, -1312, 9142, 2390, 6542, -3202, 1586, -1338, -7670, -30, -2247,
                -7026, 9901, -5207, 1987, 8821, -5442, -917, 806, -2976, 9430, 5354, -9313, 6759, -7934, 2927, -7482, 3396, -9698,
                -1471, -1244, -5555, -5641, -5737, -1910, 5366, 9351, 8334, -1808, -6905, -7261, 4963, -3095, -2182, 5958, -8823,
                -5590, -9033, -646, -1617, 8576, 1720, 6581, 6083, -3221, 5285, 3628, -5836, -735, 8717, 9181, -6408, 7221, -4517,
                620, 2876, -6106, 3918, -8395, -9241, -9576, 4047, -5657, 186, 3997, 3618, 4318, 3972, -7672, 9253, -4104, -7112,
                3392, 7546, 6915, -5796, -8429, -2082, -4709, -2890, 5826, 342, -9717, 6843, -7660, 8961, -6540, -7698, -8438,
                8941, 4507, 5493, -3822, 32, -6586, -5261, -4600, 4549, 5189, 5589, -4326, 8015, 8083, 9385, 1805, -5287, -3300,
                -7693, 4866, 3291, -3906, 6317, -5719, 5073, 1150, -1863, 7754, -5245, 9705, 2736, -5487, -5511, 1978, -2983,
                -6304, 3646, -5061, -4147, -4649, 543, 4152, 3953, -6572, 2637, -7393, -8790, 3128, -3743, 4915, -9802, -4245,
                8124, 1023, -6918, -1409, 189, 5667, 4358, 7381, 1245, 2438, -5135, 4401, 5271, 3671, 4606, 1556, 2566, 5587,
                5569, 1332, -5574, 1751, -4737, -8225, 7698, 9632, -2534, -3848, 4989, 4210, 2378, 6730, 395, -9624, 5150, 6135,
                -8669, 7560, 6134, -4102, 324, -8576, 3076, 8614, 2944, 6285, 4563, 5133, 4323, -6972, -4311, 1590, 2983, -9448,
                8296, -5044, 7524, -5525, -6877, -6307, 2547, -9833, -489, -9347, -8979, 794, -2545, 8910, -7986, -1042, -6368,
                -6098, 7841, -1841, 7563, 2316, 1406, -3473, -6927, 3741, -2254, -2632, -6644, 3504, -2141, 3194, 1131, 8911,
                1389, -2105, 6437, 8215, 8380, 3544, -8468, 1149, 1562, 7880, 6291, -2722, 4894, 3949, -8882, 5467, 7174, -7783,
                -5291, 4566, 2337, -7951, -1889, -8298, 3616, 364, 8761, 2180, -3385, -9921, 284, 1315, -5040, 3746, -9172, 6021,
                -2648, -8853, 1794, 7876, 3696, -2981, -1449, -1783, 6354, -7316, 1796, -4968, -7692, -1718, 7782, 6308, 3012,
                7747, -897, -5237, -4799, 7339, 2242, -2486, -7661, -6197, -6262, -820, 4799, -9062, -5636, -9455, -2731, 6587,
                1263, 3287, -5973, 9461, 6309, 3303, 7854, 295, 3427, 3162, -1477, 1715, -5971, 651, 3631, 4324, -1768, 734, -8462,
                7812, 8912, -7589, 3965, -9318, -5891, -6640, 4920, 912, -240, -7638, -6180, -7635, -5157, -364, -6065, 6325,
                -8966, 8047, -4600, 7131, -7907, 4580, 7084, 26, -2858, -7274, -7949, 6722, -8929, -8322, -5187, -8741, 7175,
                -4932, 1391, -4274, -3925, -8621, 4012, -8563, 2516, 3586, -1603, 7025, -6136, -3319, 5100, -2142, -2128, 707,
                2198, -4386, -142, -6506, -1804, 3700, -7770, 276, -8824, -6108, -5419, 2169, 546, 3022, -7634, 6602, 3480,
                -3583, 87, 8596, -8034, -6856, -4591, -5426, -890, -6083, 4033, -837, -1028, -9193, -4447, 5041, 7505, 4556, 424,
                4663, 7779, 7473, 364, 3800, -1230, -909, -7484, 4158, -7394, 5587, 2097, -2608, -9889, -6404, -5620, 1073, 7509,
                9016, -9856, 7189, -6033, -8190, 5849, 4093, -7701, 2971, 1189, 3648, 4924, 9888, 2863, 4702, -4258, -663, 672,
                1148, -5662, -9338, -6792, 6386, -7778, -1943, 2191, -7748, -302, 9278, 4707, 8586, 5030, 2176, 8201, 866, 8249,
                109, -9140, -6647, 7620, -6464, -1210, -3701, -3910, -7289, -9993, -766, 4940, 3427, 8137, 2094, 4027, 3523, 7252,
                9407, -5205, -5205, -3859, -2864, 297, -8286, 918, 181, 8281, 1731, -3302, 4912, -6209, 5308, -5525, -8626, 5810,
                9746, -486, -5526, 175, -1833, -9114, 2669, 1822, 3736, 4062, -7155, 5698, 6856, -24, -9373, -1831, -4065, -432,
                -4548, -649, 7354, 7451, -5205, 7882, -5542, -9813, -165, 2732, 6182, 2480, 6450, 7634, 6730, 684, -8935, -1013,
                -1554, -5676, 8745, 6954, -2655, -3538, 8158, 9896, 8174, -1968, -6958, -9349, 6401, -2804, -60, 4001, -6302, 8586,
                -3798, 2670, -239, -4354, -6328, -7967, 9870, -3425, -5824, -1199, 8276, 9162, -8656, 3829, 424, 8187, 7301,
                -1761, -7114, 5427, 9979, 5398, -1793, -8077, -3990, -5748, 5147, 7259, 3764, 4207, 3991, -9057, 8293, 4465, 8373,
                -7383, 3463, 5073, -403, 415, 9254, -8525, 4777, 3336, 6370, 7041, -7707, -1438, 5214, 845, -9565, -7323, -7836,
                8299, 1927, 3234, 2695, -9567, 9586, 3531, -7097, -1169, -3802, 4721, 5929, 2385, -8193, -8189, -2013, 591, 4175,
                7587, 4260, -8564, 9309, -9935, 4173, 6415, 9442, 7620, 7783, -8786, 1862, 8442, -3273, 4404, 2047, 6420, 6799,
                -8883, 2460, -4910, 1596, 1504, -8952, 9532, 3914, -4202, -7489, -7336, -4435, 5977, 3472, -6119, 2516, 4700,
                -7384, 7441, -1978, 3512, 9762, -7614, 5230, -6001, 6443, 365, 109, 7783, -5296, 6300, -4501, 7365, 1499, 2683,
                -5590, 6439, 1582, 4307, 2035, 2185, -4399, -608, -2789, -3887, -5374, -672, -554, 9653, -8955, -6111, -4926,
                3355, 6234, 2428, 9089, 553, 4238, 6322, -1036, 3612, 682, 9296, -5465, -2661, 8059, -3382, 6299, 7403, 1684, -268,
                1184, 654, 3777, 8662, -1301, -1679, -7714, -9449, -6251, 2774, -1731, 2338, -1540, -6925, 7810, -3684, -6612,
                786, 389, 4350, -5410, 818, -1581, -9574, -4582, -8183, -8666, 9752, -9612, -7992, 9613, -1966, -1299, 9931, 1004,
                -1433, 7965, 270, 2983, 4004, 7871, -9383, 6978, 3816, 231, -6103, -7108, 3524, 2957, 3352, 3409, -5884, 3265,
                -32, 999, -6125, 1071, 4002, 3945, 6162, 6605, -6906, -843, -4064, 9857, -8649, 6998, 9231, 4920, 9243, 700, 5606,
                7871, -3496, -412, 7518, 6224, 6725, 4860, 6243, 7384, 3034, 2374, 6250, 4284, -2314, -2140, 2496, 9254, -7422,
                -4200, 5762, 9132, 1192, -3817, -9907, -9446, 1285, 9610, 9715, -1901, -1620, 964, 1603, -2831, 1774, 7373, 1174,
                -2318, -4807, -1135, 7238, 4287, -2703, 1276, 8077, -3139, 8318, 1775, -4297, 9369, -125, 222, -7930, 9328, -5078,
                4457, 5065, -9728, -2974, 5878, -5723, -8872, 1528, 9061, -3773, -6075, 7119, 8936, 9474, -3806, -7958, 7353,
                -9316, 7860, -2675, -3398, 3409, 2765, 1798, -3563, -1745, 2667, 1124, -6129, 2911, 6602, -5555, -9774, 8937,
                -32, 6572, 9869, 7332, -7822, -355, -5797, 9215, 3812, -5382, 6874, -280, -6620, -2672, -7873, 3860, 7615, -8256,
                -3325, -8185, 6646, 7518, 6543, -7348, -3955, -1684, -47, -6521, 2821, -9372, -1243, 4499, 1612, -7643, 1314, 6402,
                9484, -9253, 7673, 7959, -7351, -9530, 1219, 8540, 3471, -5810, 4130, 9781, 6736, -9778, -2031, 3509, -8120, 6378,
                -1043, -3376, 3705, -1267, -9263, 689, -873, -4478, -6293, 1289, -662, -7638, -8867, -9207, -9438, -9841, 6051,
                9957, 2189, -9046, 6224, 3031, -803, -2924, 6031, -4977, 8278, -7604, 2195, -944, -6385, 7849, -4857, 1046, 9467,
                -6026, -2248, 9278, 6798, -9994, -3183, 4745, -1505, -1406, -7159, -6993, -5043, 7261, -6864, 6717, 6801, -3310,
                -5567, -4330, 4559, -3958, 8876, -6346, 9489, 2398, 5659, 4685, -9307, 2228, 5087, -7129, 8465, -7737, 4203, -719,
                811, 5068, 6158, -4770, -1604, -216, 2059, 5103, 3355, -9925, 2109, 2530, -6915, -212, 2539, 513, -5103, 3720,
                -3795, 2128, 4836, 9395, 8526, 8192, -4831, -5285, 2604, 1141, 5271, -1384, 8717, -6936, -2115, -1212, -4621,
                -5448, 8267, -9709, 7784, 2407, 1238, -722, 4708, -988, -6840, -4154, -6148, 4273, 4265, -2030, 3771, -6600, -6662,
                -3735, 1935, 6839, -4319, -3223, 5867, -5866, -9240, 2971, -2372, -9079, -1301, -6171, -4935, 9453, 3575, -3966,
                3293, -7172, 2480, 5859, 2698, -6394, -8347, -8710, -8384, -9296, -7196, -2111, 5168, -5356, -2829, 6317, -5945,
                3863, -963, -9809, -7574, -2656, 5048, 9622, -838, 7842, 803, -4836, -8996, -8566, -6816, -7850, -5784, -2088,
                -5808, -367, 5314, -3507, -9389, -5977, -9052, 5893, 8719, -8311, -9936, 3605, 160, 896, -787, 122, 3386, 942, 7147,
                -7139, 2131, 6461, -5769, 8108, 3542, 7468, -6578, 8366, 6608, 8495, -3086, 5902, 8715, 3964, 1980, -6715, -7036,
                -9767, -2110, 540, 7966, -9431, -2864, 3049, -3582, 3949, 1339, 4644, -8581, 1163, -8321, -124, 5861, 6982, -8563,
                1549, -4480, 199, -1133, -4734, 4359, 1255, 9495, 1669, 1541, 9956, -6004, 7904, -6188, 7039, -2274, 1711, -7577,
                8540, -2374, 3662, 8913, -6046, 2835, -7880, -803, 4709, 8936, 1013, -7027, 1940, -9848, -5823, 8150, -6548, 6813,
                2601, 7882, -2033, 9975, -3587, -1832, -8870, -6876, 2361, 9423, 5793, -1183, 220, -3046, 2209, -7303, -6136,
                -8779, 2075, -8230, -4561, -7439, -6920, 8800, -1908, 3798, -206, -992, -8088, 3174, 8988, -655, -2957, -1636,
                -6884, 8162, 4346, 8478, -8591, 8967, 4058, -3693, 6524, -7987, -8425, 8466, -3387, 6347, 6656, 5178, 3613, -2332,
                7589, 5428, -2963, -6038, -909, 5788, -5264, -98, -1968, 9678, 8743, 4529, -6202, -7424, -9374, -2401, 4026, 6799,
                -8642, 3437, 337, -2874, -3139, 9709, 6662, -2264, 760, 5364, 7639, -4800, 8808, 7971, 5718, 5839, 2677, -3854,
                7949, 8106, 2782, -3544, 8353, -8126, 3470, -5425, -3348, -8788, -1367, 6580, -7577, -4345, -343, -1589, 373, 618,
                5421, -2864, 9304, -2796, -8132, -2804, -9947, 1307, 1024, 5175, 3547, 8207, 676, 6220, -9001, -3409, 2182, 3621,
                1454, 1997, 9927, -4145, 7265, -2444, -5321, 8442, 6832, 982, -4090, -4217, -7868, -813, -7258, -86, 9091, -7208,
                9130, 614, 1092, 2685, -8632, -8919, 2367, 6038, 5375, -375, -7455, -9450, -5948, 6521, -393, 4931, -2346, -1389,
                2664, -2532, -8312, 4863, 8649, -479, -5654, -4503, 4971, 5044, -1100, 9182, -7608, 8981, -857, 1955, -3455, 9019,
                8152, 1854, 1581, 2322, -4363, 2485, 9756, 8223, -9613, -8346, -2003, 3432, 5221, -6120, 3233, -5289, 8830, 4573,
                4496, 6433, -1308, 9910, 5250, 9541, -2614, -4995, 3697, 7936, 6204, -3059, -8531, 6426, -5765, 8482, -1642, -3,
                6740, 1277, -1171, 8767, 3310, -8073, -9579, 1998, 8362, 9505, 5286, -3909, -3196, -1778, 9157, 1421, -3923, -7574,
                7196, 5715, -9060, 9047, -6847, -3970, 3236, -4711, 2947, 843, -9058, -519, -3098, -9185, 7029, -765, 578, -7418,
                3047, -3637, -6469, -5255, 6558, 5316, -2516, 7389, 890, -5659, -4878, -3893, -3398, 9881, 3955, -536, 6556, -3627,
                982, 3055, -4219, 2128, 7115, 149, -9215, 1079, 7813, 7403, -6442, 8959, 6770, -1546, -8483, -4881, 286, 8029, 586,
                -2816, 3772, 3953, 1377, 1702, 6778, 7327, 3144, 3136, -8634, -5981, -4048, -3547, -7108, -1091, 3585, -2158,
                -1529, -2282, 2250, -6881, 9598, -4006, -4474, -8972, 2082, 8043, -2681, -934, 7034, -1279, 692, 7553, 8511, 2548,
                9354, 6331, -6277, 9035, 1183, -617, 5766, 6539, 5739, 636, 8061, 8424, 1056, -3068, -1340, 6103, 1979, -9999,
                -5874, -6585, 609, -674, 5643, -9571, -6072, 4339, 1439, 7184, 4974, -3423, 4948, -6030, -3525, -3282, 8813, -9406,
                -3309, 9788, 2318, -6900, 427, 9205, -3173, 6627, 4462, -9277, 8891, 77, 7634, 5395, 7231, -3822, -914,
                8045, 616, 2637, 1673, 2415, 3264, -6945, 3542, -1718, -6626, -3260, -4300, 9760, -6674, -9708, -2126, -9659,
                -4874, 4056, -1808, 1365, -916, -6587, -5948, -1299, -8006, 750, -2711, 3687, -8985, -8365, 9746, 8986, 6876,
                -7833, 8836, 3543, -9796, 8804, -6913, -4409, -7022, 672, 5662, 3334, -6021, -3804, 9628, -9153, 2929, -2876,
                8857, -9396, -6746, 8190, -2439, 9833, -4557, -7706, -3096, 4226, 1927, -9986, -104, 6276, -9943, 4878, 1711,
                -6271, -8299, 9466, -8257, 4729, 278, 651, -931, -6664, 2853, 9177, 2240, -9152, -9251, -7724, 764, -6612, 867,
                955, 8715, 7725, -2527, 1022, -3508, 6995, 6942, 7286, -8469, -7520, -1121, -6229, 5793, -1425, -5145, -992,
                -1373, 8984, -1087, 8466, 6163, -7088, -8053, 5334, -7300, 4620, -7993, 3205, -974, 4403, -9333, 175, -3527,
                9998, -2944, 970, 5544, -9950, -2662, 547, 7357, 8714, -6885, 4742, 2197, 1802, 7964, -33, -7938, 2312, -3424,
                -4215, 2110, -8888, 1508, 7323, -7637, 9341, -84, -6129, -8909, 5097, 831, 4295, 858, 9039, 7656, -8840, 701,
                -6275, 1129, -5953, -3077, -9045, -9298, -2015, -3846, 1467, 2036, 6929, 3031, -7974, -118, 2338, 7202, 9528,
                6155, -5004, -8335, -8087, 4110, -4021, 1750, -5238, -6770, -4102, 9626, -8947, -2115, 2707, -6170, 7977, -2938,
                9832, -5467, -4740, 5934, -222, 9150, -4230, 8601, -6960, 2644, 472, -7458, -3839, -7344, -6868, -1976, 9395,
                -1563, 2781, 5411, -9166, 8312, -1052, -8428, -8629, -3403, 7104, -9491, -7282, 5933, -9737, 8221, 1877, -828,
                6353, 9781, 8291, 2929, -441, 902, -890, 8029, -1921, -8271, 2012, 7188, 5286, 8315, 545, -4886, 9099, -736, -100,
                6642, 7099, 9476, 6807, 8919, 3256, 3884, -9277, 5498, 6189, 8501, -549, 7195, 8557, -8278, -3337, -9413, -3595,
                -963, -4716, -4495, -2297, 8044, -6081, -509, -1015, -9265, -2122, 7245, -1502, -1100, -1669, -4106, 4629, -8622,
                -988, -9795, 2311, 39, 9980, 5175, -1298, -3901, -2916, 9741, 7791, 9598, -2603, 514, -5344, 7402, 2168, -4320,
                -8299, 2399, 6156, -7184, -541, 1791, -8300, 5400, 9220, 6836, 7477, 3330, 2751, -9923, 4773, -7150, 796, 2777,
                -5985, -3725, 7022, -3920, -7640, 2731, -8521, -2003, -8632, -9626, -9531, -5567, -8429, 3260, -8017, -2545, 7767,
                1601, 8112, -1173, 8284, -1016, 5441, -1059, -2275, 1108, -6116, 3751, -5637, -2795, -8904, 7962, -6841, -2040,
                -557, 42, -5200, 9392, 5621, -7515, -1056, 6021, 7750, 9182, 5537, -9641, 4118, 4648, -8398, -8303, 1334, -6327,
                468, 4871, -1680, 4133, 8062, -9437, 4166, 3623, -352, -3398, 5216, -3697, -1511, 2142, -860, 3649, 619, 1668, 6581,
                -4632, -5716, 5068, 2383, 3513, -9925, -5750, 9507, -3241, -703, -74, 8001, -3294, -3263, 8614, -9829, 8101, 2904,
                -1842, -3000, 276, 3496, -5279, -1968, 4869, -1098, -2908, 1454, -8390, 3049, 1111, -1049, -1157, 3927, 1385,
                -3450, -9989, 5118, -7389, -3025, 2295, 3808, 3180, -5767, -71, 9866, 4903, 4539, -6803, -5354, -9015, 5593, -3255,
                -4219, -4560, 5896, 7535, 4524, -1490, 9132, -2508, 8555, 8683, -9444, -7316, 7569, -7627, 8676, -7357, -1114,
                -5394, -5241, 9959, 980, -1889, 4495, 5516, 5426, -2850, -4733, 8317, 5271, -8932, -5300, -3400, 5706, -3828, 1135,
                4037, -7567, 816, -1117, -4655, 9946, -3525, 4889, -2503, 4418, -1672, -148, 5162, 6303, -7599, -7234, 9948, -9528,
                4205, -1035, 9664, 4264, -578, 5245, -3677, 6273, 7881, 5883, 464, -2514, 5082, -4549, -4780, 7999, 5206, 1305,
                6214, 3988, 3345, -9323, -5823, 2570, -3023, 4185, 6993, -6255, 8810, -8630, -229, 5059, 408, -7970, -9219, -5922,
                4782, -6490, -9063, 7386, -176, 5398, -6930, 5095, 3621, -7590, -2124, 3045, 2481, 8792, -7169, -3088, -4273,
                -4156, 698, 9254, 2798, 7844, -103, -621, -6719, -5571, -7484, -7977, 3969, -1213, -7980, 5341, 2701, -5012, 3817,
                -5450, 3828, -8717, -2503, -1203, 1939, 9147, -8583, -9350, 3307, 1552, -7742, 2829, -2815, 7744, 6228, 4617, 9713,
                6122, -978, 6972, -3879, -4606, -210, -4344, -681, -388, 7958, -7436, -9156, 4042, 9421, 1277, 5216, -5431, 2882,
                107, 9638, 4507, 1821, 6606, 674, -5373, -1994, 5878, -4583, -6078, -7389, -4044, 1915, 930, 9939, -4513, 117, 6103,
                6332, 7795, 5326, 2951, 4322, -7485, 863, -4688, 1237, -3943, -96, 9440, 8204, 9431, -3330, -7328, 4907, -3519,
                -7367, 5398, 9436, -1547, 449, 8073, 8197, -3439, 8093, -9890, 4902, 3957, -3890, 1053, -934, 4248, 7806, -4798,
                -794, 2565, 7927, -6290, 2681, 5586, 7169, -7583, 7092, 1908, -5279, -1555, 7089, 1402, 6376, -9339, 181, -2028,
                -2687, 560, 4058, 4589, 3399, -2118, -5437, -958, 5587, 1755, 3193, 4741, 9103, -5619, -4331, -7737, 1646, 9952,
        };
//        int[] arr1 = new int[]{-1, -2, -10, 10, 2, 1};
//        List<Integer> list1 = new ArrayList(Collections.singleton(arr1));
//        //System.out.println(arr1.length);
//        System.out.println(findKthLargest(arr2, 918));
//        Arrays.sort(arr2);
//        System.out.println(arr2[arr2.length - 918]);
        //System.out.println(checkRecord(10101));
//        char [] chs = new char[]{};
//        System.out.println(reverseVowels("hello"));
//        double i = Math.pow(2,3);
//        System.out.println(i==8);
//        System.out.println(isPowerOfTwo(2147483647));
//        System.out.println(Integer.MAX_VALUE);
//        if((2&1)==0){
//            System.out.println(true);
//        }
//        System.out.println(reverseStr("abcd",3));
//        int i = 0;
//        switch (true){//Incompatible types. Found: 'boolean', required: 'char, byte, short, int,
//            // Character, Byte, Short, Integer, String, or an enum'
//
//        }
        //char ch = 1+'a';
        //System.out.println(ch);
        //System.out.println(compress(new char[]{'a','a','b','b','c','c','c'}));
        //System.out.println(countDigitOne(1000000000));
//        System.out.println(findCheapestPrice(10,
//        new int[][]{{3,4,4},{2,5,6},{4,7,10},{9,6,5},{7,4,4},{6,2,10},{6,8,6},{7,9,4},{1,5,4},{1,0,4},{9,7,3},{7,0,5},{6,5,8},{1,7,6},{4,0,9},{5,9,1},{8,7,3},{1,2,6},{4,1,5},{5,2,4},{1,9,1},{7,8,10},{0,4,2},{7,2,8}},
//        6,
//        0,
//        7));
//        List<Integer>listtmp = new ArrayList<>();
//        listtmp.add(1);
//        listtmp.add(0);
//        System.out.println(listtmp.remove(1));
//        List<List<Integer>> l = permuteUnique(new int[]{1,1,2});
//        for (int i = 0; i < l.size(); i++) {
//            for (int j = 0; j < l.get(i).size(); j++) {
//                System.out.print(l.get(i).get(j)+" ");
//            }
//            System.out.println();
//        }
//        int[] arr1 = new int[]{1,2,3};
//        ArrayList<Integer>  l = new ArrayList<>();
//        l.add(9);
//        //l.add("ab");
//        for(Object o:l){
//            System.out.println(o);
//        }

//        int []arr1 = new int[0];
//        System.out.println(arr1.length);
        //System.out.println(findPeakElement(new int[]{3, 2, 1}));
        //System.out.println(maxVowels_1456("ibpbhixfiouhdljnjfflpapptrxgcomvnb" , 33));
//        List<Integer>l = new ArrayList<>();
//        int tmp;
//        System.out.println();
//        int tmp[] = findPeakGrid(new int[][]{{1, 4, 6}, {2, 9, 5}, {7, 8, 3}});
//        System.out.println(tmp[0]+" "+tmp[1]);
        //System.out.println(sumOddLengthSubarrays(new int[]{1, 4, 2, 5, 3}));
//        StringBuilder sb1 = new StringBuilder();
//        StringBuilder sb2 = new StringBuilder();
//        sb1.append("012");
//        sb2.append('a');
//        String s = "a";
//        //s.split('.');
//        System.out.println(Integer.valueOf(sb1.toString()));
//        //System.out.println(sb1.toString().compareTo(sb2.toString()));
//        System.out.println(compareVersion("0.1", "1.1"));
//        List<Integer> l1 = new ArrayList<>();
//        l1.add(12);
//        l1.add(18);
//        l1.stream().allMatch(new Predicate<Integer>() {
//            @Override
//            public boolean test(Integer integer) {
//                return false;
//            }
//        });
        //System.out.println(fib(48));
//        Map<String ,String> map = new HashMap<>();
//        map.put("1","1");
        //map.co
//        String[][] strs = {{"David","3","Ceviche"},{"Corina","10","Beef Burrito"},{"David","3","Fried Chicken"},{"Carla","5","Water"},{"Carla","5","Ceviche"},{"Rous","3","Ceviche"}};
//        List<List<String>> orders = new ArrayList<>();
//        for(int i = 0;i<strs.length;i++) {
//            orders.add(Arrays.asList(strs[i]));
//        }
//        System.out.println(displayTable(orders));
        //System.out.println(findMaximizedCapital(2,0,new int[]{1,2,3},new int[]{0,1,1}));
//        for(int j = 0;j<100;j++){
//            Random r = new Random(j);
//            int []arr1 = new int[10];
//            for(int i = 1;i<10;i++){
//                arr1[i] = r.nextInt();
//            }
//            for(int i = 0;i<10;i++){
//                System.out.print(arr1[i]+" ");
//            }
//            System.out.println();
//            for(int i = 5;i>=1;i--){
//                adjustDown(arr1,i,10);
//            }
//            System.out.print("heap sort:");
//            for(int i = 0;i<10;i++){
//                System.out.print(arr1[i]+" ");
//            }
//            int []tmparr = checkHeap(arr1,1);
//            System.out.println(j+" "+tmparr[0]+" "+tmparr[1]+" "+tmparr[2]);
//        }
//        System.out.println(findIntegers(12));
//        ArrayList<Integer> list1 = new ArrayList<>();
//        list1.iterator()
//        System.out.println(smallestMissingValueSubtree(new int[]{-1,4,4,4,0}, new int[]{2,4,5,1,3}));
//        System.out.println(findLongestWord("aaa",new ArrayList<String>(Arrays.asList(new String[]{"ale","apple","monkey","plea"}))));
//        Map<Integer,Integer> map = new HashMap<>();
//        List l = new ArrayList<>(new HashSet<>());
//        System.out.println(isValidSudoku(new char[][]{
//                {'5','3','.','.','7','.','.','.','.'}
//                ,{'6','.','.','1','9','5','.','.','.'}
//                ,{'.','9','8','.','.','.','.','6','.'}
//                ,{'8','.','.','.','6','.','.','.','3'}
//                ,{'4','.','.','8','.','3','.','.','1'}
//                ,{'7','.','.','.','2','.','.','.','6'}
//                ,{'.','6','.','.','.','.','2','8','.'}
//                ,{'.','.','.','4','1','9','.','.','5'}
//                ,{'.','.','.','.','8','.','.','7','9'}
//        }));
//        System.out.println(minSteps(12));
//        char[][]charWords = new char[][]{{'a','a'}
//                //{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}
//        };
//        String[] words = new String[]{"a"};
//        System.out.println(findWords(charWords,words));
//        TreeSet<Student> set = new TreeSet(new Comparator() {
//            @Override
//            public int compare(Object o1, Object o2) {
//                return ((Student)o1).getName().compareTo(((Student)o2).getName());
//            }
//        });
//        set.add(new Student(10,"zhao"));
//        set.add(new Student(11,"zhao"));
//        set.add(1);
//        set.add(2);
//        set.add(6);
//        System.out.println(set);

//        System.out.println(countAndSay(6));
//        Node head = new Node(1);
//        Node n1 = new Node(2);
//        Node n2 = new Node(3);
//        Node n3 = new Node(4);
//        Node n4 = new Node(5);
//        Node n5 = new Node(6);
//        Node n6 = new Node(7);
//        Node n7 = new Node(8);
//        Node n8 = new Node(9);
//        Node n9 = new Node(10);
//        Node n10 = new Node(11);
//        Node n11= new Node(12);
//        head.next = n1;
//        n1.prev = head;
//
//        n1.next = n2;
//        n2.prev = n1;
//
//        n2.next = n3;
//        n3.prev = n2;
//        n2.child = n6;
//
//        n3.next = n4;
//        n4.prev = n3;
//
//        n4.next = n5;
//        n5.prev = n4;
//
//        n6.next = n7;
//        n7.prev = n6;
//
//        n7.next = n8;
//        n8.prev = n7;
//        n7.child = n10;
//
//        n8.next = n9;
//        n9.prev = n8;
//
//        n10.next = n11;
//        n11.prev = n10;
//        flatten(head);
//        func("ABCD".toCharArray());
//        System.out.println(toHex(26));
//        System.out.println(fractionToDecimal(1,333));
//        StringBuilder sb = new StringBuilder();
//        System.out.println(fractionToDecimal(-1,-2147483648));
//        System.out.println(thirdMax(new int[]{2,1}));
//        System.out.println(findRepeatedDnaSequences("AAAAAAAAAAA"));
//        int[][] ints = new int[][]{{1, 1}};
//        List<int[]> list = new ArrayList<>();
//
//        list.add(new int[]{1, 1});
//        int [][] res = list.toArray(new int[ints.length][]);
//        int flag = 3;
//        System.out.println(flag & 1);
//        String s = ", , , ,        a, eaefa";
//        String[] s1 = s.split(" ");
//        System.out.println(s1);
//        System.out.println(divide(-2147483648,2));
//        System.out.println(longestCommonSubsequence("abc","def"));
        //String s = System.in.read();
//        StringBuilder sb = new StringBuilder();
//        System.out.println(areNumbersAscending("hello world 5 x 5"));
//        List list = new ArrayList(new ArrayList());
//        System.out.println(countMaxOrSubsets(new int[]{3, 1}));
//        System.out.println(findComplement(5)) ;
//        System.out.println(~-5);
//        String str = new String();
//        System.out.println(minMoves(new int[]{1000000000}));
//        Queue<Integer> q = new LinkedList<>();
//        TreeNode root = new TreeNode();
//        root.value = 3;
//        TreeNode node1 = new TreeNode();
//        node1.value = 1;
//        TreeNode node2 = new TreeNode();
//        node2.value = 2;
//        TreeNode node3 = new TreeNode();
//        node3.value = 4;
//        root.left = node1;
//        node1.right = node2;
//        root.right = node3;
//        System.out.println(kthSmallest(root,1));
//        System.out.println(countValidWords("a-b-c"));
//        System.out.println(nextGreaterElement(new int[]{4,1,2},new int[]{1,3,4,2}));
//        StringBuilder sb = new StringBuilder();
//        char [] chs = new char[32];
//        Arrays.sort(chs);
//        new String(chs);
//        System.out.println(reorderedPowerOf2(24));
//        List<Integer> list = new ArrayList<>();
//        new ArrayList<>(list);
//        Set<Integer> set = new HashSet<>();
//        set.remove(1);
//        System.out.println(singleNumber(new int[]{-1139700704,-1653765433}));
//        System.out.println(1^-1);
//        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {
//            @Override
//            public int compare(int[] o1, int[] o2) {
//                return o2[2]-o1[2];
//            }
//        });
//        pq.peek()
//        System.out.println(platesBetweenCandles("***|**|*****|**||**|*", new int[][]{{1,17},{4,5},{14,17},{5,11},{15,16}}));
//        System.out.println(findWords(new String[]{"Hello", "Alaska", "Dad", "Peace"}));
//        for(int i = 1;i < 31;i++){
//            int tmp = (int) Math.pow(2,i);
//            System.out.println(my_toBinary(tmp));
//            System.out.println(i+" "+fun1(tmp)+" " +fun2(tmp)+" "+fun3(tmp));
//        }
//        char[] chs = new char[10];
//        new String(chs,0,5);
//        System.out.println(getHint("00112233445566778899","16872590340158679432"));
//        System.out.println(my_toBinary(100000000));
//        StringBuilder sb = new StringBuilder();
//        System.out.println(originalDigits("zeroonetwothreefourfivesixseveneightnine"));
//        System.out.println(flip(3,1));
//        System.out.println(numberOf2sInRange(22));
//        System.out.println(findAnagrams("bbaa","aabb"));
//        System.out.println(findRelativeRanks(new int[]{5,4,3,2,1}));
//        System.out.println(largestSumAfterKNegations(new int[]{5,6,9,-3,3}, 1));
//        System.out.println(canConstruct("a","b"));
//        System.out.println(superPow(209253,
//                new int[]{3,6,4,3,0,7,9,2,9,7,8,7,7,0,3,8,6,0,0,8,0,8,3,4,4,4,9,9,6,7,3,3,6,7,8,6,4,8,8,3,7,9,2,4,1,5,4,9,7,4,8,8,4,3,4,8,9,6,0,6,3,3,1,1,2,1,8,8,1,8,3,8,9,5,4,0,3,9,0,0,5,0,0,0,5,5,0,7,1,0,5,6,5,6,8,9,9,8,7,1,6,0,9,6,8,6,8,1,5,0,3,0,0,4,0,8,1,1,5,2,3,0,0,9,8,8,8,7,6,8,8,5,8,0,3,8,6,3,1,3,4,5,3,6,1,6,4,2,9,9,6,2,1,6,1,9,7,2,7,5,0,7,0,0,9,5,9,7,9,2,0,3,9,4,1,0,0,6,4,9,7,2,3,9,9,5,8,8,9,7,3,9,7,4,9,6,1,0,6,0,3,6,5,4,2,7,5,2,3,1,3,0,4,9,1,5,6,0,3,5,9,6,4,6,2,5,5,4,8,1,4,3,7,2,7,0,9,4,4,4,6,0,6,2,9,8,7,5,0,0,0,9,8,6,6,1,3,1,5,3,2,1,6,1,3,6,1,4,2,6,0,8,8,9,2,7,7,9,4,7,1,4,8,0,2,4,3,5,7,0,1,9,1,7,1,7,5,4,3,8,2,6,8,0,5,1,9,2,2,3,1,6,9,9,8,1,6,1,9,3,1,0,5,4,9,8,3,5,4,7,5,7,3,3,9,8,6,9,2,9,2,5,5,2,6,3,5,2,6,6,8,7,6,5,3,8,5,7,5,9,6,0,8,9,5,8,9,2,7,3,3,1,0,0,5,6,5,3,1,1,9,1,0,6,6,3,6,3,2,1,2,8,1,1,9,8,1,0,2,0,3,5,1,3,7,9,2,2,2,3,3,1,4,3,9,2,9,5,5,1,6,9,0,9,2,9,0,3,0,2,5,5,0,9,1,7,8,3,0,2,8,3,5,4,9,7,6,8,2,3,9,1,4,1,2,9,3,2,4,5,5,0,0,7,9,3,4,9,6,4,1,6,0,8,0,9,5,8,9,0,3,0,1,8,2,5,9,7,0,3,2,7,3,2,4,4,8,8,3,4,3,6,3,3,5,3,4,0,2,5,0,7,5,3,5,9,9,6,6,1,0,8,8,5,3,2,0,1,0,3,7,5,2,0,0,7,4,6,7,8,1,0,5,7,5,3,6,4,9,5,7,1,3,5,7,6,7,9,9,0,4,7,5,6,9,6,3,5,2,3,5,4,5,1,3,0,6,1,7,7,6,4,1,0,0,8,8,7,9,8,7,3,7,5,2,8,3,5,4,5,0,9,1,7,2,6,8,0,8,7,8,4,1,9,6,3,9,5,3,8,5,2,3,4,7,5,2,0,3,6,8,5,8,9,3,0,6,3,1,6,0,1,0,1,2,7,5,1,4,8,1,1,2,6,7,0,2,9,0,7,8,0,2,8,2,7,8,0,0,1,6,0,2,8,4,4,7,1,7,1,1,0,4,3,7,1,3,1,3,6,8,1,8,0,9,0,8,9,0,0,3,6,1,5,5,7,2,2,8,1,6,9,4,0,2,1,4,8,2,7,6,2,0,4,2,1,5,2,0,7,3,3,4,6,1,1,3,5,5,1,8,1,2,2,4,6,5,0,6,7,7,2,9,9,9,4,0,6,8,0,3,3,6,9,1,9,2,4,4,8,7,4,1,1,7,7,8,2,7,4,2,6,9,3,5,0,9,7,6,0,8,1,3,6,1,5,5,5,1,1,5,1,5,7,2,4,6,2,9,6,9,3,4,8,8,2,8,8,9,6,8,7,7,3,5,0,8,0,6,2,3,1,3,1,0,7,5,7,0,6,5,9,9,9,9,8,1,9,8,1,5,6,0,4,1,6,5,2,8,3,4,2,4,9,3,7,6,0,4,8,7,1,9,8,0,8,6,2,9,6,5,4,2,5,1,6,3,6,8,2,9,4,6,5,3,9,2,1,1,8,0,8,9,9,7,2,0,5,6,9,2,1,6,6,8,7,2,2,5,2,6,6,6,2,1,9,3,6,3,4,6,3,5,6,4,2,0,6,9,6,8,1,7,4,0,5,1,4,9,6,7,5,4,3,7,5,5,2,3,8,7,0,3,2,8,9,6,8,6,5,4,4,9,3,0,9,0,1,3,0,9,0,5,3,6,5,0,1,7,6,9,6,6,2,8,6,1,4,6,9,2}));
//        System.out.println(_superPow(209253,
//                new int[]{3,6,4,3,0,7,9,2,9,7,8,7,7,0,3,8,6,0,0,8,0,8,3,4,4,4,9,9,6,7,3,3,6,7,8,6,4,8,8,3,7,9,2,4,1,5,4,9,7,4,8,8,4,3,4,8,9,6,0,6,3,3,1,1,2,1,8,8,1,8,3,8,9,5,4,0,3,9,0,0,5,0,0,0,5,5,0,7,1,0,5,6,5,6,8,9,9,8,7,1,6,0,9,6,8,6,8,1,5,0,3,0,0,4,0,8,1,1,5,2,3,0,0,9,8,8,8,7,6,8,8,5,8,0,3,8,6,3,1,3,4,5,3,6,1,6,4,2,9,9,6,2,1,6,1,9,7,2,7,5,0,7,0,0,9,5,9,7,9,2,0,3,9,4,1,0,0,6,4,9,7,2,3,9,9,5,8,8,9,7,3,9,7,4,9,6,1,0,6,0,3,6,5,4,2,7,5,2,3,1,3,0,4,9,1,5,6,0,3,5,9,6,4,6,2,5,5,4,8,1,4,3,7,2,7,0,9,4,4,4,6,0,6,2,9,8,7,5,0,0,0,9,8,6,6,1,3,1,5,3,2,1,6,1,3,6,1,4,2,6,0,8,8,9,2,7,7,9,4,7,1,4,8,0,2,4,3,5,7,0,1,9,1,7,1,7,5,4,3,8,2,6,8,0,5,1,9,2,2,3,1,6,9,9,8,1,6,1,9,3,1,0,5,4,9,8,3,5,4,7,5,7,3,3,9,8,6,9,2,9,2,5,5,2,6,3,5,2,6,6,8,7,6,5,3,8,5,7,5,9,6,0,8,9,5,8,9,2,7,3,3,1,0,0,5,6,5,3,1,1,9,1,0,6,6,3,6,3,2,1,2,8,1,1,9,8,1,0,2,0,3,5,1,3,7,9,2,2,2,3,3,1,4,3,9,2,9,5,5,1,6,9,0,9,2,9,0,3,0,2,5,5,0,9,1,7,8,3,0,2,8,3,5,4,9,7,6,8,2,3,9,1,4,1,2,9,3,2,4,5,5,0,0,7,9,3,4,9,6,4,1,6,0,8,0,9,5,8,9,0,3,0,1,8,2,5,9,7,0,3,2,7,3,2,4,4,8,8,3,4,3,6,3,3,5,3,4,0,2,5,0,7,5,3,5,9,9,6,6,1,0,8,8,5,3,2,0,1,0,3,7,5,2,0,0,7,4,6,7,8,1,0,5,7,5,3,6,4,9,5,7,1,3,5,7,6,7,9,9,0,4,7,5,6,9,6,3,5,2,3,5,4,5,1,3,0,6,1,7,7,6,4,1,0,0,8,8,7,9,8,7,3,7,5,2,8,3,5,4,5,0,9,1,7,2,6,8,0,8,7,8,4,1,9,6,3,9,5,3,8,5,2,3,4,7,5,2,0,3,6,8,5,8,9,3,0,6,3,1,6,0,1,0,1,2,7,5,1,4,8,1,1,2,6,7,0,2,9,0,7,8,0,2,8,2,7,8,0,0,1,6,0,2,8,4,4,7,1,7,1,1,0,4,3,7,1,3,1,3,6,8,1,8,0,9,0,8,9,0,0,3,6,1,5,5,7,2,2,8,1,6,9,4,0,2,1,4,8,2,7,6,2,0,4,2,1,5,2,0,7,3,3,4,6,1,1,3,5,5,1,8,1,2,2,4,6,5,0,6,7,7,2,9,9,9,4,0,6,8,0,3,3,6,9,1,9,2,4,4,8,7,4,1,1,7,7,8,2,7,4,2,6,9,3,5,0,9,7,6,0,8,1,3,6,1,5,5,5,1,1,5,1,5,7,2,4,6,2,9,6,9,3,4,8,8,2,8,8,9,6,8,7,7,3,5,0,8,0,6,2,3,1,3,1,0,7,5,7,0,6,5,9,9,9,9,8,1,9,8,1,5,6,0,4,1,6,5,2,8,3,4,2,4,9,3,7,6,0,4,8,7,1,9,8,0,8,6,2,9,6,5,4,2,5,1,6,3,6,8,2,9,4,6,5,3,9,2,1,1,8,0,8,9,9,7,2,0,5,6,9,2,1,6,6,8,7,2,2,5,2,6,6,6,2,1,9,3,6,3,4,6,3,5,6,4,2,0,6,9,6,8,1,7,4,0,5,1,4,9,6,7,5,4,3,7,5,5,2,3,8,7,0,3,2,8,9,6,8,6,5,4,4,9,3,0,9,0,1,3,0,9,0,5,3,6,5,0,1,7,6,9,6,6,2,8,6,1,4,6,9,2}));
//        for(int i = 0;i<superPow_list1.size() && i<superPow_list2.size();i++){
//            if(superPow_list2.get(i)[0] != superPow_list1.get(i)[0] ||
//                    superPow_list2.get(i)[1] != superPow_list1.get(i)[1] ){
//                System.out.println(i+" "+"difference");
//            }
//        }
//        TopVotedCandidate(new int[]{0,1,1,0,0,1,0},new int[]{0,5,10,15,20,25,30});
//        int query[] = new int[]{3,12,25,15,24,8};
//        for(int i = 0;i<query.length;i++){
//            System.out.println(q(query[i]));
//        }
//        System.out.println(scheduleCourse(new int[][]{{100,200},{200,1300},{1000,1250},{2000,3200}}));
//        System.out.println(loudAndRich(new int[][]{{1,0},{2,1},{3,1},{3,7},{4,3},{5,3},{6,3}},new int[]{3,2,5,4,6,1,7,0}));
//        System.out.println(longestDupSubstring("aa"));
//        System.out.println(eatenApples(new int[]{1,2,3,5,2}, new int[]{3,2,1,4,2}));
//        Deque dq = new ArrayDeque();
//        System.out.println(isNStraightHand(new int[]{8, 10, 12},3));
//        main_1();
//        Integer.toBinaryString(2);//n
//        StringBuilder sb = new StringBuilder();
//        sb.delete();
//        System.out.println(simplifyPath("/"));
        //["ll","lb","bb","bx","xx","lx","xx","lx","ll","xb","bx","lb","bb","lb","bl","bb","bx","xl","lb","xx"]
//        System.out.println(longestPalindrome(new String[]{"ll","lb","bb","bx","xx","lx","xx","lx","ll","xb","bx","lb","bb","lb","bl","bb","bx","xl","lb","xx"}));
//        System.out.println(wordCount(new String[]{"t"},new String[]{"nsewcbujhad","aeb","phvbaeinctkwl","cybwlsuzinvk","qwhxytpvefrjz","gvy","ixcalbqfz","igftodzvcnswjlm","thbdfgivurj","nbd","dgqolunivxs","bcsovemfldan","unhzrsd","skwlendhyucapzi","zyrmohljp","qum","btmzgfqaspwjeh","jgkmzqoyvtw","tlgrawcxkn","qdwogyrfs","gephoxvsdj","dfvxywjknm","wru","jnumkcfydo","ewhbxfqgkclsj","lz","ghxopqbey","xc","jiznkxvcues","uykrcxaofhm","vmqdipal","zjkmbqxtyefsicr","fiawpvldc","h","dompynwi","zbkynwmcxgves","mxi","ranoytupxb","pyaqedhvzgjcbifl","fy","nrobdxvspqyjgui","snrm","gfyknowupqrta","wivmt","qtxyhcblrakfdg","vfczbhtoa","reho","o","rzn","rabsgdfxij","gpyhft","jiv","ufqji","xe","pnifxjhmtosa","j","vzodg","cthzjspulafxiwb","ohbmuqn","rdliztsjukcwfpv","saoqpd","pxu","kxnguybvejfwo","fukagtlbndmpry","sqlpaytnvhkrmo","pm","umco","imjqrd","riq","vywxz","npiu","rvzjq","qso","epkloxmr","racvl","znkcwbg","sfp","mguztnorf","pnjogwuyztacev","qdyxcfzbhp","bcwhdqzjultrai","sfvheigw","vgqb","brsyjegvmhdc","xwuadlp","aft","pinl","gctwje","ufjzmdp","ohbxag","cdfamgpntkwu","ruaekpdbfqtzclj","cesowgvpltxjihdr","nfy","jftgxplc","zhlgtxou","tljanzupriodew","rlesyncqbkftuoh","eqslt","giotujnrwfdce","qldztvnyguwxso","vjkdfzuaseitxo","rdimnopgzhlw","ckrjyqwplitsfo","dwvj","wgje","qcmrxk","qgflbvxhn","qoniymsa","ftdcoxpqakigrejv","hrusofb","qcm","scwykazqb","riswegfoctj","tq","ekoc","sjpkg","dikj","sqigfbrel","eoknxfrup","ot","djfsbwkpuhl","yvafsiku","clnbxzg","ivbhygjqrxan","rit","msprwq","hfdjmckqzpulrw","hfwazycos","kdmnqztsi","nrhol","lctab","svf","crxngv","gczkqjs","agfqzhmy","dvoxgmh","ndvcuykgh","vct","nywvhcxbd","e","pbufvcszi","ql","agvpjizktbwsorfn","zxvgbkwca","omeayvfwhqzrpi","fmgcxeutzdk","ldpbcrayxztsjvw","nxt","ypluzeavsqw","zmbv","rucwispfa","iucj","jnhbzw","vqhetubalnf","poivetgflayxkjhr","tje","nr","spygwiqr","ewyuforkmpicnx","vg","hakjcn","aygvphcszitqwku","baovglc","qmurcdzbhy","wucgnfmlsjz","kslongxrqhcmz","pgfvquewxncalksb","drqhje","parmfuzhdkvb","orfwcqbsv","uoq","iocesyphtzxvuwk","oisafxherlpvjd","xrbw","iktsg","dag","ifpyer","onerqivbwmjz","ia","kemzasyxndgjhoc","ukvj","celxkzuhwypbva","y","agejbtoqislvh","xiopwdtfkba","fqbihmywglxdnc","cjmeizw","ghzfqw","eylv","jbuylhnfk","pkyfr","rf","dyvhipqjmgrezaf","kcolxfmgnqvyz","nphgbcujmo","fqupgtrxvis","f","drishmtobjqcapv","exutnvc","pkzcqhmgnf","ycgqbdtsenmlhf","k","wtgerl","lqa","ku","i","ydlzsgfirbjx","owecuxrpm","i","ekr","tglokjeyc","ckmfij","coxekquhwmd","kfsdwcq","hnpymjovxue","twqyv","demvwrtcsiabglq","y","kvnqszx","g","ewtuijhxyo","mwhrsfxjgeb","dwxfbntusoa","lhiboak","kune","ow","awzpn","jqesgiuzrdpx","rijvynudo","ycvutdmgkroiexa","qvo","wupmsxni","rcpnhx","wsbcanhpe","sdelrbyxqukzmw","qhrygcuabnv","fruaynbsedwqxh","flyhcwnaoej","ni","rbtopmn","jvtdensy","few","dn","a","chg","h","tiwdrbp","tdm","qghetodvsjimbp","hymzfvgsobc","kdqstyjznvhapb","oem","lb","mhod","adjhexcpqmny","ljsiq","whgdyxmzcs","tc","vyquexhzlwirbo","gykq","qhmjgo","wmcrasnoxf","xzrbwvpefnoj","eyhaqspxvkrdcu","ncbtsvzfr","kwal","slfyi","fz","nzbdmr","akpdhycirg","ofrbxuc","ajkyobq","tkxhd","tjcxrw","qiruxdljayvw","xhvakznmibru","shgizj","mtgbuokycqjwz","lbodjf","xbgmzwslkup","ix","tefw","szlqbfcrvewxh","yugjdax","aekjsruy","womqkfdny","jgzw","lavbxr","lijybwtshfva","fwvlt","abhvjc","ub","qew","kwimvrfxsn","mldvjhbsxkfqtp","gfewmbh","oe","adurofqsiwcyek","mrahvpzxqo","gxtbcrjvnayquk","agdukwhevqynjl","fal","jzrvwinkusldbot","qnia","kwhuiacrvobp","ewmr","rmwdsvtgp","zctjunxidevybl","ckuexlrgpn","dh","dczbrilvhnwpaqt","ustilnpkfowzy","bknrejhxopmgzf","uzvteaj","xnkie","dxbtswmrekfvncu","yeuaxkilbcshopq","ax","suchdoxfbn","iegrpnd","qetwovbjs","kxrobvsuwzd","suwj","xsgdcavhoeyrznl","fo","vtpyhaowszmq","hfwonijbvdzxsua","onatjk","sau","dvbwoatyjsxpgefl","na","mglfynh","ywlkdcbnx","qwvojklutydran","aql","gdol","m","ufskachixjtmbd","kxlwg","klgmyuparhtox","fvshdugarpyejqzt","ejidg","uknhpsfqdotvjya","novyphxwj","blxps","d","kc","cnaroqj","qu","incfrutp","ci","dtugyziblrqh","dsfoquxevlarht","zwmnptjau","ytecmgvjf","maoictxvjus","uwhxytnv","tbmzpscehxkarwoi","ztxv","kigyjb","frlapn","wcveqlpj","arz","bfqkiatlmvsueo","jkepaqwimx","jefodwbt","xcnqwdhtlkmiryp","xulkbnq","ot","m","jchodig","wcqgmilbajzs","zekqsxwgfdjyblc","nmxavdocguybrtp","bkyczmptogqiu","mastzincjxqb","nzm","dxpfaoelg","hygbrxamzcov","b","pkgvdzsrcyo","whqopvdgexfntaz","iowrnxkltsv","f","nvcuymzwf","sxevmktrdyqpga","ulwzsntvhgo","fkvzgxbadmihc","kmferiap","gnpylhidxqvre","zfunlhxpajsmte","psomxbu","tpyz","vrbnpzicehqlk","vut","hmosw","wrcoegynlmihktq","ehujpgb","teurhbpola","te","qmhvgazpy","qn","xgkevnmujhbcw","cednjuyzfrk","bl","tvjsdkzgbfrnolx","o","jeszr","lf","pxmrstykena","etkaqgywb","xitepcoqmywnabr","phfeo","tuzkb","ltcpynmzkhe","qf","jceaqor","vikewzdsflayrh","amipvtk","bqjxfctm","xyuflbwdni","zjn","avnyhxtgcbmsj","fyxztlw","rhiksqzwbncdu","jnsgkmxz","mbhfu","unrqvayjeiocsld","ugb","iu","orjyfb","cfxyv","dkrzslecipt","rh","otuwqevildhsfpbj","lsxrizef","ufwl","vpbsgxlucam","zldruejvg","qdszvjpgh","omqlsijg","zrjsyimekutopv","tqiwgkjxhp","pmldfswutjenyo","juzltnvkgwm","istbrgxek","zsekjfihrbmdgtl","ntxlkarzsfvo","tfzmsyn","junvwaoiy","iuehozgtv","gwpfkry","jyuwpvil","zor","mrxfkeiguqcy","tlops","jvratnwemgupsl","ufvrzmts","dpkjsfmthglwic","bhkandtjwvgpr","gbcmstwonrvj","gnsxietuyvohjc","np","rpjyhckie","tj","fhoxkpinujs","boq","vlytmzbcj","nboyucs","f","tmkrbvcequgolsi","inthajrleycopd","mzpkoteqjfhgxr","wifjoezhqlaydrg","dufr","zsg","rafzbmldtkc","uamgpkrzet","eajgftqzl","ifkgbcwn","mbgqnsrv","thgewzbiufdp","ng","oszkxyeritnw","npvryhas","gqwpnlft","gtbsreykoi","ytcuaefbkwo","whv","indxwfc","zqi","snvihkaglfxp","zjlefovgdby","jlkwuacx","jzkocbnaismqdv","qxnz","fehcipdbnv","qwhpxnejfy","lrnwjz","jfduoehpxgs","md","dej","erbipdhgnquwjc","utyabgm","mrghpwtnaiqkfc","mlcoq","smxavtwkeizo","j","anjwekzo","gvsoqdbwnc","ribnmhugpt","zxqgtkh","lh","zvib","ianrw","ozekxhrdqpl","gdns","fxymzdjbthang","vynmo","segtfrnjzuvd","h","x","qlfwdxjzna","jmlrotpyhcuv","zfwsqrgxk","lmq","qwdifkjecshung","utdihflv","mnuvsawckq","ucakhswdtbn","oaedpl","rohtbfdxnzei","cu","vdlcw","tsgudkwo","ugijehftmalzv","ehmkjblipgv","n","bd","sgko","neb","qxbuingv","fcvtpjadqz","zqnrskbme","ldgxwijqnkrfcp","cnj","lcqxgyena","hufobzqekpxvldm","ctxn","ab","aolvmzespbrnjg","io","kbhwspg","jwhomcr","npfl","zidqsvpunjbyaxc","bav","tmwrjlsed","jzibvwcstlgrk","hizmbwqyge","onyxbergpvjul","o","noigbrtqzhuwpsdm","wgyoitnkacj","cleatwzurifgdxoj","ydprewfczknlt","yjiemrltqhkfzd","qbhe","y","uhgq","a","eptlxqmoairfyjds","pytesjdvo","ulajndfgx","knvpfcmldwbios","ejqxawcop","c","xhloesfqypb","j","yflgq","vcyu","chqztuvn","vmwubperxk","samxt","po","t","exfdpatnwosk","xcqonaptfmlsd","tlmayecdkisrpbz","hgyvzlbxetufjmw","fsgakpcndiuzeb","m","luevtfj","avguom","afqwnblsomk","qlozdybwcfnhk","fosmbqua","afdmrgsqwxvo","lzdfjtbqc","qhagb","qeimns","xnhrs","xdtwiymhskqoa","hfbgnwjuzevlkpr","by","ogtlerhvdmbi","epcdgwajviourbx","pdohxc","oxqkbethrlwnpma","pwdhq","tkgnzbhverafc","zlpbvitakqrf","ynbfxwpc","ygmxtiv","ybtpaudw","nagxrepfl","rvp","rhbiavct","vmqspyzfuw","ajex","fgjrad","zr","wzk","jk","rkqzmjabip","ditpyqoxwnzgja","ybsnciveoakjlmq","ywverqzmujginxc","czvrm","bazyusfmdtjgie","yhmlbrtxskuwqa","pnqgesyzuvwkt","ahpntv","kmgcndrfyzpoj","zobskapmlj"}));
//        System.out.println(wordCount_1(new String[]{"tqnu","jld","gnb","bux","qut"},new String[]{"mtqnu","n","l","jauw","ubh","qutn","cqkbs","nkrog","bhl","qjld"}));//        System.out.println(earliestFullBloom(new int[]{1,2,3,2},new int[]{2,1,2,1}));
//        System.out.println(combinationSum(new int[]{2,3,4}, 7));
//        String str = "3210";
//        System.out.println(str.substring(0,1));
//        System.out.println(str.substring(2));
//        System.out.println(3 * Integer.MIN_VALUE);
//        System.out.println(isAdditiveNumber("112358"));
//        System.out.println("11".substring(2).length());
//        System.out.println(isAddable("1","9","10"));
//        List<Integer> list = new ArrayList(){{
//            add(1);
//            add(2);
//        }};
//        System.out.println("hello");
//        System.out.println(kSmallestPairs(new int[]{1,2,4,5,6}, new int[]{3,5,7,9}, 20));
//        System.out.println(permuteUnique_1(new int[]{1,1,2}));
//        StringBuilder sb = new StringBuilder("ab");
//        Random r = new Random();
//        r.setSeed(1);
//        r.nextInt(3);
//        System.out.println(mostPoints(new int[][]{{21,5},{92,3},{74,2},{39,4},{58,2},{5,5},{49,4},{65,3}}));
//        System.out.println(threeSum(new int[]{-1,0,1,2,-1,-4}));
//        StringBuilder s = new StringBuilder("a");
//        s.split();
//        List<String> list = new ArrayList<>();
//        list.add("00:00");
//        list.add("23:59");
//        System.out.println(findMinDifference(list));
//        Stack<Integer> s = new Stack<>();
//        Deque<Integer> dq = new ArrayDeque<>();
//        System.out.println(dq.peek());
////        s.pee
//        Set<Integer> set = new HashSet<>();
//        set.add();
//        System.out.println(minJumps(new int[]{100,-23,-23,404,100,23,23,23,3,404}));
//        System.out.println(exist(new char[][]{{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}},"ABCCED"));
//        System.out.println(movingCount(1,2,1));
//        Map<int[],Integer> map = new HashMap<>();
//        map.put(new int[]{3, 2}, 1);
//        map.put(new int[]{3, 2}, 2);
//        System.out.println(map.containsKey(new int[]{3, 2}));//mapkeymapkeystringlist

//        DetectSquares ds = new DetectSquares();
//        ds.add(new int[]{5,10});
//        ds.add(new int[]{10,5});
//        ds.add(new int[]{10,10});
//        System.out.println(ds.count(new int[]{5,5}));
//        ds.add(new int[]{3,0});
//        ds.add(new int[]{8,0});
//        ds.add(new int[]{8,5});
//        System.out.println(ds.count(new int[]{3,5}));
//        ds.add(new int[]{9,0});
//        ds.add(new int[]{9,8});
//        ds.add(new int[]{1,8});
//        System.out.println(ds.count(new int[]{1,0}));
//        ds.add(new int[]{0,0});
//        ds.add(new int[]{8,0});
//        ds.add(new int[]{8,8});
//        System.out.println(ds.count(new int[]{0,8}));

//        ds.add(new int[]{3,10});
//        ds.add(new int[]{11,2});
//        ds.add(new int[]{3,2});
//        System.out.println(ds.count(new int[]{11,10}));
//        System.out.println(ds.count(new int[]{14,8}));
//        ds.add(new int[]{11,2});
//        System.out.println(ds.count(new int[]{11,10}));

//        int [][]arr1 = new int[][]{{2,1},{1,2}};
//        Arrays.sort(arr1, new Comparator<int[]>() {
//            @Override
//            public int compare(int[] o1, int[] o2) {
//                return o1[0] - o2[0];
//            }
//        });
//        System.out.println("hello");
//        System.out.println(secondMinimum(2, new int[][]{{1,2}}, 3, 2));
//        TreeNode node5 = new TreeNode(2, null, null);
//        TreeNode node4 = new TreeNode(1, null, null);
//        TreeNode node3 = new TreeNode(4, node4, node5);
//        TreeNode node2 = new TreeNode(5, null, null);
//        TreeNode node1 = new TreeNode(3, node3, node2);
//
//        TreeNode b_2 = new TreeNode(1, null, null);
//        TreeNode b_1 = new TreeNode(4, b_2, null);
//        System.out.println(isSubStructure(node1, b_1));
//        TreeNode node7 = new TreeNode(3, null, null);
//        TreeNode node6 = new TreeNode(4, null, null);
//        TreeNode node5 = new TreeNode(4, null, null);
//        TreeNode node4 = new TreeNode(3, null, null);
//        TreeNode node3 = new TreeNode(2, node6, node7);
//        TreeNode node2 = new TreeNode(2, node4, node5);
//        TreeNode node1 = new TreeNode(1, node2, node3);
//        System.out.println(isSymmetric(node1));
//        System.out.println(spiralOrder(new int[][]{{1,2,3,4},{5,6,7,8},{9,10,11,12}}));
//        TreeMap<Integer, Integer> tm = new TreeMap<>();
//        System.out.println(validateStackSequences(new int[]{1,2,3,4,5}, new int[]{4,5,3,2,1}));
//        StringBuilder sb = new StringBuilder();
//        System.out.println(findNthDigit(2147483647));

//        TreeNode node5 = new TreeNode(5, null, null);
//        TreeNode node4 = new TreeNode(4, null, null);
//        TreeNode node3 = new TreeNode(3, node4, node5);
//        TreeNode node3 = new TreeNode(3, null, null);
//        TreeNode node2 = new TreeNode(2, null, null);
//        TreeNode node1 = new TreeNode(1, node2, node3);
//        String s = serialize(node1);
//        TreeNode root = deserialize(s);
//        System.out.println(s);
//        System.out.println(reversePairs(new int[]{7,5,6,4}));
//        System.out.println(verifyPostorder(new int[]{1,6,3,2,5}));
//        System.out.println(gridIllumination(5, new int[][]{{0,0}, {4,4}}, new int[][]{{1, 1},{1, 0}}));
//        System.out.println(minNumber(new int[]{3,30,34,5,9}));
//        int i = 1;
//        int j = 2;
//        double tmp  = i / j;// i  jdouble
//        System.out.println(tmp);
//        int[][] res = findContinuousSequence( 15);
//        System.out.println(res);
//        Set<Integer> set = new LinkedHashSet<>();
//        System.out.println(isStraight(new int[]{1,2,3,4,5}));
//        System.out.println(knightProbability(3, 2, 0, 0));
//        System.out.println(restoreIpAddresses("25525511135"));
//        TreeNode node3 = new TreeNode(8, null, null);
//        TreeNode node2 = new TreeNode(2, null, null);
//        TreeNode node1 = new TreeNode(6, node2, node3);
//        System.out.println(lowestCommonAncestor(node1, node2, node3));
//        System.out.println(pushDominoes(".L.R...LR..L.."));
        //
//        System.out.println(isEscapePossible(new int[][]{{0,199},{1,198},{2,197},{3,196},{4,195},{5,194},{6,193},{7,192},{8,191},{9,190},{10,189},{11,188},{12,187},{13,186},{14,185},{15,184},{16,183},{17,182},{18,181},{19,180},{20,179},{21,178},{22,177},{23,176},{24,175},{25,174},{26,173},{27,172},{28,171},{29,170},{30,169},{31,168},{32,167},{33,166},{34,165},{35,164},{36,163},{37,162},{38,161},{39,160},{40,159},{41,158},{42,157},{43,156},{44,155},{45,154},{46,153},{47,152},{48,151},{49,150},{50,149},{51,148},{52,147},{53,146},{54,145},{55,144},{56,143},{57,142},{58,141},{59,140},{60,139},{61,138},{62,137},{63,136},{64,135},{65,134},{66,133},{67,132},{68,131},{69,130},{70,129},{71,128},{72,127},{73,126},{74,125},{75,124},{76,123},{77,122},{78,121},{79,120},{80,119},{81,118},{82,117},{83,116},{84,115},{85,114},{86,113},{87,112},{88,111},{89,110},{90,109},{91,108},{92,107},{93,106},{94,105},{95,104},{96,103},{97,102},{98,101},{99,100},{100,99},{101,98},{102,97},{103,96},{104,95},{105,94},{106,93},{107,92},{108,91},{109,90},{110,89},{111,88},{112,87},{113,86},{114,85},{115,84},{116,83},{117,82},{118,81},{119,80},{120,79},{121,78},{122,77},{123,76},{124,75},{125,74},{126,73},{127,72},{128,71},{129,70},{130,69},{131,68},{132,67},{133,66},{134,65},{135,64},{136,63},{137,62},{138,61},{139,60},{140,59},{141,58},{142,57},{143,56},{144,55},{145,54},{146,53},{147,52},{148,51},{149,50},{150,49},{151,48},{152,47},{153,46},{154,45},{155,44},{156,43},{157,42},{158,41},{159,40},{160,39},{161,38},{162,37},{163,36},{164,35},{165,34},{166,33},{167,32},{168,31},{169,30},{170,29},{171,28},{172,27},{173,26},{174,25},{175,24},{176,23},{177,22},{178,21},{179,20},{180,19},{181,18},{182,17},{183,16},{184,15},{185,14},{186,13},{187,12},{188,11},{189,10},{190,9},{191,8},{192,7},{193,6},{194,5},{195,4},{196,3},{197,2},{198,1},{199,0}}, new int[]{0, 0}, new int[]{200, 200}));
//        System.out.println(isEscapePossible(new int[][]{{10,9},{9,10},{10,11},{11,10}}, new int[]{0, 0}, new int[]{10, 10}));
//        System.out.println(findBall(new int[][]{{-1,-1,-1,-1,-1},{1,1,1,1,1},{-1,-1,-1,-1,-1},{1,1,1,1,1},{-1,-1,-1,-1,-1}}));
//        System.out.println(findBall(new int[][]{{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}}));
//        String str = "1+1i";
//        String []strs = str.split("\\+");
//        long now=System.currentTimeMillis();
//        TreeMap<Integer, Integer> tm = new TreeMap<>();
//        Map.Entry<Integer, Integer> integerIntegerEntry = tm.firstEntry();
//        LRUCache lruCache = new LRUCache(2);
//        System.out.println(lruCache.get(2));
//        lruCache.put(2, 6);
//        System.out.println(lruCache.get(1));
//        lruCache.put(1, 5);
//        lruCache.put(1, 2);
//        System.out.println(lruCache.get(1));
//        System.out.println(lruCache.get(2));
//        System.out.println(System.currentTimeMillis() * 1000 + System.nanoTime());
//        lruCache.put(4, 4);
//        System.out.println(lengthOfLIS(new int[]{0,1,0,3,2,3}));
//        int[] nums = new int[]{2,1,3};
//        System.out.println(convert("PAYPALISHIRING", 3));
//        System.out.println(second_compareVersion("0.1", "1.1"));
//        System.out.println(nearestPalindromic("99"));

//        Scanner sc = new Scanner(System.in);
//        my_main();
//        my_main1();
//        System.out.println("hello");
//        my_main2();
//        int []arr1 = new int[]{250,145,145,145,145};
//        for(int i = 0; i < arr1.length; i++){
//            System.out.println(my_toBinary(arr1[i]));
//        }
//        System.out.println(validUtf8(arr1));
//        System.out.println(findRestaurant(new String[]{"S","TEXP","BK","KFC"}, new String[]{"KFC","BK","S"}));
//        AllOne allOne = new AllOne();
//        allOne.inc("a");
//        allOne.inc("b");
//        allOne.inc("b");
//        allOne.inc("c");
//        allOne.inc("c");
//        allOne.inc("c");
//
//        allOne.dec("b");
//        allOne.dec("b");
//        System.out.println(allOne.getMinKey());
//        allOne.dec("a");
//        System.out.println(allOne.getMaxKey());
//        System.out.println(allOne.getMinKey());
//        System.out.println(networkBecomesIdle(new int[][]{{0, 1}, {1, 2}}, new int[]{0, 2, 1}));
//        String str1 = "a";
//        String str2 = "b";
//        System.out.println(str1.compareTo(str2));
//        System.out.println(longestWord_2(new String[]{"wo","wor","worl", "world"}));
//        AdjacentTable adj = new AdjacentTable();
//        adj.countHighestScoreNodes(new int[]{-1,2,0,2,0});
//        System.out.println();
//        List<Integer> list = new ArrayList<>();
//        list.add(0);
//        list.get(10);
//        C_2049 c2049 = new C_2049();
//        c2049.countHighestScoreNodes(new int[]{-1,2,0,2,0});
//        System.out.println(imageSmoother(new int[][]{{100,200,100},{200,50,200},{100,200,100}}));
//        splitIntoFibonacci("17522");
//        System.out.println(nextGreatestLetter(new char[]{'c', 'j','f'},'c'));
//        System.out.println(fun5(10));
//        System.out.println(numDistinct("rabbbit", "rabbit"));
//        System.out.println(findMinHeightTrees(6, new int[][]{{0,1},{0,2},{0,3},{3,4},{4,5}}));
//        System.out.println(minJump(new int[]{2,5,1,1,1,1}));
//        RandomizedSet rset = new RandomizedSet();
//        System.out.println(rset.remove(0));
//        System.out.println(rset.remove(0));
//
//        System.out.println(rset.insert(0));
//        System.out.println(rset.getRandom());
//        System.out.println(rset.remove(0));
//        System.out.println(rset.insert(0));

//        System.out.println(containsNearbyDuplicate(new int[]{1, 1, 2}, 1));
//        new ConcurrentHashMap();
//        System.out.println(largestPalindrome(8));
//        String p = "ab   c";
//        String[] words = p.split(" ");
//        System.out.println(words.length);
//        System.out.println(mostCommonWord(new String("Bob hit a ball, the hit BALL flew far after it was hit."),
//                new String[]{"hit"}));
//        System.out.println(mostCommonWord(new String("Bob. hIt, baLl"),new String[]{"hit", "bob"}));
//        System.out.println(lexicalOrder(13));
//        new ArrayList<>(new HashSet<>());
//        Arrays.sort(new int[]{-1, 1});
//        System.out.println(findTheWinner(5, 3));
//        ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap();
//        concurrentHashMap.put()
//        System.out.println(minMutation("AAAAAAAA", "CCCCCCCC",new String[]{"AAAAAAAA","AAAAAAAC","AAAAAACC","AAAAACCC","AAAACCCC","AACACCCC","ACCACCCC","ACCCCCCC","CCCCCCCA","CCCCCCCC"}));
//        System.out.println(new Integer(123) == 123); //new Integer(123) != new Integer(123)
//        Integer i = 42;
//        String s = (i < 40) ? "life" : (i > 50) ? "u" : "e";
//        System.out.println(lengthOfLIS_b_search(new int[]{10,9,2,5,3,7,101,18}));
//        List<Integer> height = new ArrayList<>();
//        height.get(0);
//        Queue<Integer> q = new ArrayDeque<>();
//        System.out.println(validIPAddress("2001:0db8:85a3:0:0:8A2E:037j:7334"));
//        String str = "";
//        String[] strs = str.split(":");
//        System.out.println(strs.length);
//        Deque<Integer> dq = new ArrayDeque<>();
//        dq.poll();
//        System.out.println(jump(new int[]{2}));
//        Student[] stds = new Student[10];
//        System.out.println(stds[0] == null);
//        ConcurrentHashMap con = new ConcurrentHashMap();
//        con.put();
//        System.out.println(32 - (32 >>> 2));
//        System.out.println(smallestDistancePair(new int[]{1, 1, 1}, 1));
//        duplicateZeros(new int[]{8,4,5,0,0,0,0,7});
//        ListNode n1 = new ListNode(1);
//        ListNode n2 = new ListNode(2);
//        ListNode n3 = new ListNode(3);
//        ListNode n4 = new ListNode(4);
//        ListNode n5 = new ListNode(5);
//        n1.next = n2;
//        n2.next = n3;
//        n3.next = n4;
//        n4.next = n5;
//        ReverseList(n1);
//        ListNode res = reverseKGroup(n1, 2);
//        System.out.println(InversePairs(new int[]{1,2,3,4,5,6,7,0}));
//        System.out.println(maxSubArray(new int[]{-2,1,-3,4,-1,2,1,-5,4}));

//        System.out.println(removeStones(new int[][]{{0,0},{0,2},{1,1},{2,0},{2,2}}));
//        System.out.println(compare("1.1", "2.1"));
        TreeNode n1 = new TreeNode(8);
        TreeNode n2 = new TreeNode(4);
        TreeNode n3 = new TreeNode(12);
        TreeNode n4 = new TreeNode(2);
        TreeNode n5 = new TreeNode(6);
        TreeNode n6 = new TreeNode(10);
        TreeNode n7 = new TreeNode(14);
        TreeNode n8 = new TreeNode(1);
        TreeNode n9 = new TreeNode(3);
        TreeNode n10 = new TreeNode(5);
        TreeNode n11 = new TreeNode(7);
        TreeNode n12 = new TreeNode(9);
        TreeNode n13 = new TreeNode(11);
        TreeNode n14 = new TreeNode(13);
        TreeNode n15 = new TreeNode(15);

        n1.left = n2;
        n1.right = n3;
        n2.left = n4;
        n2.right = n5;
//        String str = Serialize(n1);
//        TreeNode root = Deserialize(str);
//        System.out.println(Serialize(n1));
//        n3.left = n6;
//        n3.right = n7;
//        n4.left = n8;
//        n4.right = n9;
//        n5.left = n10;
//        n5.right = n11;
//        n6.left = n12;
//        n6.right = n13;
//        n7.left = n14;
//        n7.right = n15;
//        System.out.println(Print(n1));
//        System.out.println(solve(new int[]{1,2,4,5,3}, new int[]{4,2,5,1,3}));
//        String age = "10";
//        String a1 = "zhangsan" + age;
//        String a2 = "zhangsan10";
//        System.out.println(a1 == a2);
//        System.out.println(maxInWindows(new int[]{2,3,4,2,6,2,5,1}, 3));
//        System.out.println(findKth(new int[]{9,9,12,5,10,6}, 6, 3));
//        int[] arr_tmp = new int[]{5,2,3,4,1,6,7,0,8};
//        for(int i : arr_tmp){
//            Insert(i);
//            System.out.println(GetMedian());
//        }
        SkipList sp= new SkipList();
        int[] level = new int[]{2,3};

        for(int i = 1; i < 3; i++){
            sp.insert(i);
        }
    }
    static PriorityQueue<Integer> pqRight = new PriorityQueue();
    static PriorityQueue<Integer> pqLeft = new PriorityQueue(new Comparator<Integer>(){
        public int compare(Integer o1, Integer o2){
            return o2 - o1;
        }
    });
    public static void Insert(Integer num) {
        pqLeft.offer(num);
        while(pqLeft.size() - pqRight.size() >= 2){
            pqRight.offer(pqLeft.poll());
        }
        while(pqLeft.size() >0 && pqRight.size() > 0 && pqLeft.peek() > pqRight.peek()){
            pqRight.offer(pqLeft.poll());
            pqLeft.offer(pqRight.poll());
        }
    }
    public static Double GetMedian(){
        if(pqLeft.size() == pqRight.size()){
            double t1 = (double)pqLeft.peek();
            double t2 = (double)pqRight.peek();
            return (t1 + t2) / 2;
        }else if(pqLeft.size() + 1 == pqRight.size()){
            return (double) pqRight.peek();
        }else{
            return (double)pqLeft.peek();
        }
    }
    public static int findKth(int[] a, int n, int K) {
        return quickSort(a, 0, n - 1, K);
    }
    public static int quickSort(int[] a, int s, int e, int K){
        int index = fun(a, s, e, K);

        if(K - 1 == index){
            return a[index];
        }else if(K - 1 < index){
            return quickSort(a, s, index - 1, K);
        }else{
            return quickSort(a, index + 1, e, K);
        }
    }
    public static int fun(int[] a, int s, int e, int K){
//        if(s == e && s + 1 == K){
//            return a[s];
//        }
        int i = s;
        int j = e;
        int p = a[s];
        while(i < j){
            while(i < j && a[j] <= p){
                j--;
            }
            a[i] = a[j];
            while(i < j && a[i] >= p){
                i++;
            }
            a[j] = a[i];
        }
        a[i] = p;
        return i;
    }
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> res = new ArrayList();

        PriorityQueue<Integer> pq = new PriorityQueue();
        for(int i = 0; i < input.length; i++){
            pq.offer(input[i]);
        }
        for(int i = 0; i < k; i++){
            res.add(pq.poll());
        }
        return res;
    }
    public static ArrayList<Integer> maxInWindows(int [] num, int size) {
        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>(){
            public int compare(int[] o1, int[] o2){
                return o2[0] - o1[0];
            }
        });
        for(int i = 0; i < size - 1; i++){
            pq.offer(new int[]{num[i], i});
        }
        ArrayList<Integer> res = new ArrayList();
        for(int i = size - 1; i < num.length; i++){
            pq.offer(new int[]{num[i], i});
            while(!pq.isEmpty()){
                int[] tmp = pq.peek();
                if(tmp[1] <= i - size){
                    pq.poll();
                }else{
                    res.add(tmp[0]);
                    break;
                }
            }
        }
        return res;
    }
    static int EMPTY = Integer.MAX_VALUE;
    static TreeNode empytyNode = new TreeNode(EMPTY);
    static String Serialize(TreeNode root) {
        if(root == null){
            return "" + EMPTY;
        }
        StringBuilder sb = new StringBuilder();
        Queue<TreeNode> queue = new ArrayDeque();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(node.value != EMPTY){
                sb.append(node.value);
                if(node.left != null){
                    queue.offer(node.left);
                }else{
                    queue.offer(new TreeNode(EMPTY));
                }
                if(node.right != null){
                    queue.offer(node.right);
                }else{
                    queue.offer(new TreeNode(EMPTY));
                }
            }else{
                sb.append(EMPTY);
            }
            sb.append("_");
        }
        sb.deleteCharAt(sb.length() - 1);
        return sb.toString();
    }
    static TreeNode Deserialize(String str) {
        if(("" + EMPTY).equals(str)){
            return null;
        }
        String[] strs = str.split("_");
        Queue<TreeNode> queue = new ArrayDeque();
        TreeNode root = new TreeNode(Integer.valueOf(strs[0]));
        queue.offer(root);
        for(int i = 1; i < strs.length - 1; i += 2){
            TreeNode node = queue.poll();
            TreeNode leftNode = new TreeNode(Integer.valueOf(strs[i]));
            TreeNode rightNode = new TreeNode(Integer.valueOf(strs[i + 1]));
            if(Integer.valueOf(leftNode.value) != EMPTY){
                node.left = leftNode;
                queue.offer(leftNode);
            }else{
                node.left = null;
            }
            if(Integer.valueOf(rightNode.value) != EMPTY){
                node.right = rightNode;
                queue.offer(rightNode);
            }else{
                node.right = null;
            }
        }
        return root;
    }
    static Map<Integer, Integer> mapXianXu = new HashMap();
    static Map<Integer, Integer> mapZhongXu = new HashMap();
    public static int[] solve (int[] xianxu, int[] zhongxu) {
        // write code here
        for(int i = 0; i < xianxu.length; i++){
            mapXianXu.put(xianxu[i], i);
            mapZhongXu.put(zhongxu[i], i);
        }
        //
        TreeNode root = create(xianxu, zhongxu, 0, xianxu.length - 1, 0, zhongxu.length - 1);
        //
        List<List<Integer>> list = new ArrayList();
        dfs(root, 0, list);
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++){
            List<Integer> tmp = list.get(i);
            res[i] = tmp.get(tmp.size() - 1);
        }
        return res;
    }
    public static TreeNode create(int[] xianxu, int[] zhongxu, int s1, int e1, int s2, int e2){
        if(s2 > e2){
            return null;
        }
        TreeNode root = new TreeNode(xianxu[s1]);
        int index = mapZhongXu.get(xianxu[s1]);
        int lenLeft = index - s2;
        root.left = create(xianxu, zhongxu, s1 + 1, s1 + lenLeft, s2, index - 1);
        root.right = create(xianxu, zhongxu, s1 + 1 + lenLeft, e1, index + 1, e2);
        return root;
    }
    public static void dfs(TreeNode root, int level, List<List<Integer>> list){
        if(root != null){
            if(list.size() <= level){
                list.add(new ArrayList());

            }
            list.get(level).add(root.value);
            dfs(root.left, level + 1, list);
            dfs(root.right, level + 1, list);
        }
    }
    public static ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> res = new ArrayList();
        Queue<TreeNode> q = new ArrayDeque();
        q.offer(pRoot);
        int level = 0;
        while(!q.isEmpty()){
            int count = q.size();
            ArrayList<Integer> tmp_res = new ArrayList(count);
            while(count > 0){
                TreeNode node = q.poll();
                if(node.left != null){
                    q.offer(node.left);
                }
                if(node.right != null){
                    q.offer(node.right);
                }

                count--;
            }
            if(level % 2 != 0){
                reverse(tmp_res);
            }

            res.add(tmp_res);
            level++;
        }
        return res;
    }
    public static void reverse(List<Integer> list){
        for(int i = 0, j = list.size() - 1; i < j; i++, j--){
            int tmp = list.get(i);
            list.set(i, list.get(j));
            list.set(j, tmp);
        }
    }
    public static int compare (String version1, String version2) {
        // write code here
        String[] str1 = version1.split("\\.");
        String[] str2 = version2.split("\\.");
        int i = 0;
        for (; i < str1.length && i < str2.length; i++) {
            int tmp1 = Integer.valueOf(str1[i]);
            int tmp2 = Integer.valueOf(str2[i]);
            if (tmp1 != tmp2) {
                return tmp1 - tmp2;
            }
        }
        if (i < str1.length) {
            while (i < str1.length) {
                if (Integer.valueOf(str1[i]) != 0) {
                    return 1;
                }
                i++;
            }
            return 0;
        } else {
            while (i < str2.length) {
                if (Integer.valueOf(str2[i]) != 0) {
                    return -1;
                }
                i++;
            }
            return 0;
        }
    }
    public static int removeStones(int[][] stones) {
        class UnionFind{
            private Map<Integer, Integer> map;
            private int count ;
            public UnionFind(){
                map = new HashMap();
                count = 0;
            }
            public int getCount(){
                return count;
            }
            public int find(int x){
                if(!map.containsKey(x)){
                    map.put(x, x);
                    count++;
                }
                if(x != map.get(x)){
                    map.put(x, find(map.get(x)));
                }
                return map.get(x);
            }
            public void union(int x, int y){
                int root_x = find(x);
                int root_y = find(y);
                if(root_x == root_y){
                    return;
                }
                map.put(root_x, root_y);
                count--;
            }
        }
        UnionFind ud = new UnionFind();
        for(int[] stone : stones){
            int x = stone[0];
            int y = stone[1];
            ud.union(x + 10001, y);
        }
        return stones.length - ud.getCount();
    }

    public static int maxSubArray_1(int[] nums) {
        int sum = 0;
        int max = 0;
        for(int i = 0; i < nums.length; i++){
            sum = Math.max(sum + nums[i], nums[i]);
            max = Math.max(sum, max);
        }
        return max;
    }
    public static ListNode mergeKLists(ArrayList<ListNode> lists) {

        ListNode res = new ListNode(-1);
        ListNode head = res;
        Queue<ListNode> pq = new PriorityQueue(new Comparator<ListNode>(){
            public int compare(ListNode n1, ListNode n2){
                return n1.val - n2.val;
            }
        });
        for(int i = 0; i < lists.size(); i++){
            pq.offer(lists.get(i));
        }
        while(!pq.isEmpty()){
            ListNode tmp = pq.poll();
            res.next = tmp;
            res = tmp;
            if(tmp.next != null){
                pq.offer(tmp.next);
            }
        }
        return head.next;
    }
    public static ListNode reverseKGroup (ListNode head, int k) {
        // write code here
        ListNode dumyNode = new ListNode(-1);
        dumyNode.next = head;
        ListNode pre_h1 = dumyNode;
        ListNode h1 = head;
        ListNode next = null;
        for(int i = 1; head != null; i++){
            if(i % k == 0){
                next = head.next;
                head.next = null;
                reverse(h1);
                pre_h1.next = head;
                h1.next = next;
                pre_h1 = h1;
                head = next;
                h1 = next;
            }else{
                head = head.next;
            }

        }
        return dumyNode.next;
    }
    public static ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode next = null;
        while(head != null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
    public static ListNode reverseBetween (ListNode head, int m, int n) {
        // write code here
        ListNode L = new ListNode(0);
        L.next = head;
        ListNode pre_m = L;
        ListNode mNode = null;
//         ListNode next = null;
        ListNode pre = L;
        ListNode next = null;
        int i = 1;
        while(head != null && i <= n){
            next = head.next;
            if(i == m - 1){
                pre_m = head;
                mNode = head.next;
            }
            if(i == n){
                mNode.next = head.next;
                pre_m.next = head;
            }
            if(i > m && i <= n){
                head.next = pre;
            }
            pre = head;
            i++;
            head = next;
        }

        return L.next;
    }
    static ListNode _l = null;
    public static ListNode ReverseList(ListNode head) {
        ListNode l = fun(head);
        l.next = null;
        return _l;
    }
    public static ListNode fun(ListNode head){
        if(head != null && head.next == null){
            _l = head;
            return head;
        }else{
            ListNode node = fun(head.next);
            node.next = head;
            return head;
        }
    }
    public static void duplicateZeros(int[] arr) {
        int[] res = new int[arr.length];
        for(int i = 0, j = 0; j < arr.length; i++, j++){
            if(arr[i] == 0){
                res[j] = 0;
                if(j + 1 >= arr.length){
                    return;
                }else{
                    res[++j] = 0;
                }
            }else{
                res[j] = arr[i];
            }
        }
        for(int i = 0; i < arr.length; i++){
            arr[i] = res[i];
        }
    }
    public static int smallestDistancePair(int[] nums, int k) {
        int min = 1000000;
        int max = 0;
        for(int i = 0; i < nums.length; i++){
            min = Math.min(nums[i], min);
            max = Math.max(nums[i], max);
        }
        Arrays.sort(nums);
        int end = max - min;
        int start = 0;
        while(end >= start){
            int mid = (end - start) / 2 + start;
            int cnt = fun(nums, mid);//numsmidcnt
            if(cnt < k){
                start = mid + 1;
            }else if(cnt > k){
                end = mid;
            }else{
                return mid;
            }
            k -= cnt;
        }
        return start;
    }
    public static int fun(int[] nums, int dis){
        int res = 0;
        int start = 0;
        int end = 0;
        for(; end < nums.length;){
            if(nums[end] - nums[start] <= dis){
                end++;
            }else{
                res += end - 1 - start;
                start++;
            }
        }
        res += end - 1 - start;
        return res;
    }
    public static int jump(int[] nums) {
        Set<Integer> set = new HashSet();
        Deque<Integer> queue = new ArrayDeque();
        int level_end = 0;
        int first = -1;
        int end = 0;
        int res = 1;
        queue.add(0);
        while(!queue.isEmpty()){
            int index = queue.pop();
            first++;
            for(int j = index + 1; j < index + nums[index] + 1 && j < nums.length; j++){
                if(set.contains(j)){
                    continue;
                }
                if(j == nums.length - 1){
                    return res;
                }
                queue.add(j);
                set.add(j);
                end++;
            }
            if(level_end == first){
                res++;
                level_end = end;
            }
        }
        return -1;
    }
    public static String validIPAddress(String queryIP) {
        if(isIPV4(queryIP)){
            return "IPv4";
        }else if(isIPV6(queryIP)){
            return "IPv6";
        }else{
            return "Neither";
        }
    }
    public static boolean isIPV4(String queryIP){
        String[] strs = queryIP.split("\\.");
        if(strs.length != 4){
            return false;
        }
        for(int i = 0; i < strs.length; i++){
            if(strs[i].charAt(0) == '0' && Integer.valueOf(strs[i]) != 0){
                return false;
            }
            if(Integer.valueOf(strs[i]) > 255){
                return false;
            }
        }
        return true;
    }
    public static boolean isIPV6(String queryIP){
        if(!isHex(queryIP)){
            return false;
        }
        String[] strs = queryIP.split(":");
        if(strs.length != 8){
            return false;
        }
        for(int i = 0; i < strs.length; i++){
            if(strs[i].length() > 4){
                return false;
            }
            Integer x = Integer.parseInt(strs[i], 16);
            int max = 1 << 16;
            if(x > max - 1){
                return false;
            }
        }
        return true;
    }
    public static boolean isHex(String queryIP){
        for(int i = 0; i < queryIP.length(); i++){
            if((queryIP.charAt(i) >= '0' && queryIP.charAt(i) <= '9') || (queryIP.charAt(i) >= 'a' && queryIP.charAt(i) <= 'f' || (queryIP.charAt(i) >= 'A' && queryIP.charAt(i) <= 'F'))){
                continue;
            }else{
                return false;
            }
        }
        return true;
    }
    public static int lengthOfLIS_b_search(int[] nums) {
        //dp
        //dp + 
        int n = nums.length;
        List<Integer> dp = new ArrayList<>();
        dp.add(nums[0]);
        int len = 1;
        for(int i = 1; i < nums.length; i++){
            if(nums[i] > dp.get(dp.size() - 1)){
                dp.add(nums[i]);
//                len++;
            }else{
                int index = b_search(dp, nums[i]);
                dp.set(index, nums[i]);
            }
        }
        return dp.size();
    }
    public static int b_search(List<Integer> dp, int target){
        int start = 0;
        int end = dp.size() - 1;
        while(start < end){
            int mid = (end - start) / 2 + start;
            if(dp.get(mid) >= target){
                end = mid;
            }else{
                start = mid + 1;
            }
        }
        return start;
    }
    public static int minMutation(String start, String end, String[] bank) {
        List<Integer>[] arr_list = new ArrayList[bank.length + 1];
        for(int i = 0; i < bank.length + 1; i++){
            arr_list[i] = new ArrayList();
        }
        for(int j = 0; j < bank.length; j++){
            if(fun(start, bank[j]) == 1){
                arr_list[0].add(j + 1);
            }
        }
        for(int i = 0; i < bank.length; i++){
            for(int j = 0; j < bank.length; j++){
                if(fun(bank[i], bank[j]) == 1){
                    arr_list[i + 1].add(j + 1);
                }
            }
        }
        Queue<Integer> queue = new ArrayDeque();
        queue.offer(0);
        Set<Integer> visited = new HashSet();
        visited.add(0);
        int res = 0;
        int begin = -1;
        int e = 0;
        int level = 0;
        while(!queue.isEmpty()){
            int s = queue.poll();
            begin++;
            for(int i = 0; i < arr_list[s].size(); i++){
                int next = arr_list[s].get(i);
                if(!visited.contains(next)){
                    queue.offer(arr_list[s].get(i));
                    e++;
                    visited.add(arr_list[s].get(i));
                    if(bank[next - 1].equals(end)){
                        return res + 1;
                    }
                }
            }
            if(begin == level){
                res++;
                level = e;
            }
        }
        return -1;
    }
    public static int fun( String str1, String str2){
        int diff = 0;
        for(int k = 0; k < 8; k++){
            if(str1.charAt(k) != str2.charAt(k)){
                diff++;
            }
        }
        return diff;
    }
    public static int findTheWinner(int n, int k) {
        boolean[] flag = new boolean[n];
        int j = 0;
        for(int i = 0; i < n - 1; i++){
            int cnt = 1;
            for(; cnt < k; j++){
                if(flag[j % n] == false){
                    cnt++;
                }
            }
            flag[j % n] = true;
            j++;
        }
        for(int i = 0; i < n; i++){
            if(flag[i] == false){
                return i + 1;
            }
        }
        return -1;
    }
    public static List<Integer> lexicalOrder(int n) {
        List<Integer> res = new ArrayList();
        for (int k = 1; k <= 9; k++) {
            dfs(k, res, n);
        }
        return res;
    }
    public static void dfs(int root, List<Integer> res, int n){
        if(root > n){
            return;
        }
        res.add(root);
//        dfs(root * 10, res, n);
        for(int i = 0; i <= 9 && root + i <= n; i++){
            dfs(root * 10 + i, res, n);
        }
    }
    public static String mostCommonWord(String paragraph, String[] banned) {
        Map<String, Integer> map = new HashMap();
        StringBuilder strBuider = new StringBuilder();
        for(int i = 0; i < paragraph.length(); i++){
            if(paragraph.charAt(i) >= 'A' && paragraph.charAt(i) <= 'Z'){
                strBuider.append((char)(paragraph.charAt(i) + 32));
            }else{
                strBuider.append(paragraph.charAt(i));
            }
        }
        int i = -1, j = 0;
        for(; j < strBuider.length(); j++){
            if(isAlphaBeta(strBuider.charAt(j)) == -1){
                if(j - i > 1){
                    String word = strBuider.substring(i + 1, j);
                    map.put(word, map.getOrDefault(word, 0) + 1);
                }
                i = j;
            }
        }
        if(isAlphaBeta(strBuider.charAt(strBuider.length() - 1)) != -1 ){
            String word = strBuider.substring(i + 1, j);
            map.put(word, map.getOrDefault(word, 0) + 1);
        }
        int max = 0;
        String res = "";
        Set<String> set = new HashSet();
        for(int k = 0; k < banned.length; k++){
            set.add(banned[k]);
        }
        for(String str_tmp : map.keySet()){
            if(!set.contains(str_tmp) && map.get(str_tmp) > max ){
                max = map.get(str_tmp);
                res = str_tmp;
            }
        }
        return res;
    }

    public static int isAlphaBeta(char c){
        if(c <= 'Z' && c >= 'A'){
            return 0;
        }
        if(c <= 'z' && c >= 'a'){
            return 1;
        }
        // if(c == ' '){
        //     return true;
        // }
        return -1;
    }
    public static int largestPalindrome(int n) {
        if(n == 1){
            return 9;
        }
        int upper = (int)Math.pow(10, n) - 1;
        for(int i = upper; i > 0; i--){
            long x = i;
            for(int j = i; j > 0; j = j / 10){//
                x = x * 10 + j % 10;
            }
            for(long j = upper; j * j >= x; j--){
                if(x % j == 0){
                    return (int)(x % 1337);
                }
            }
        }
        return -1;
    }
    public static boolean containsNearbyDuplicate(int[] nums, int k){

        Map<Integer, Integer> map = new HashMap();
        for(int i = 0; i < nums.length; i++){
            if(!map.containsKey(nums[i])){
                map.put(nums[i], i);
            }else{
                int index = map.get(nums[i]);
                if(i - index <= k){
                    return true;
                }else{
                    map.put(nums[i], i);//
                }
            }
        }
        return false;
    }

    public static int minJump(int[] jump) {
        if(jump.length == 1){
            return 0;
        }
        Queue<Integer> dq = new ArrayDeque();
        int[] res = new int[jump.length + 1];
        int n = jump.length;
        dq.offer(0);
        while(!dq.isEmpty()){
            int cur = dq.poll();
            for(int i = 1; i <= jump[cur]; i++){
                if(cur + i >= n){
                    return res[cur] + 1;
                }
                if(res[cur + i] == 0){
                    dq.offer(cur + i);
                    res[cur + i] = res[cur] + 1;
                }else{
                    res[cur + i] = Math.min(res[cur] + 1, res[cur + i]);
                }
            }
        }
        if(res[jump.length - 1] == 0){
            return -1;
        }
        return res[jump.length - 1];
    }
    public static List<Integer> findMinHeightTrees(int n, int[][] edges) {
        if(n == 1){
            List<Integer> list = new ArrayList();
            list.add(0);
            return list;
        }
        List<Integer>[] adjacent = new ArrayList[n];
        int[] degree = new int[n];
        for(int i = 0; i < n; i++){
            adjacent[i] = new ArrayList();
        }
        for(int i = 0; i < edges.length; i++){
            int x = edges[i][0];
            int y = edges[i][1];
            adjacent[x].add(y);
            adjacent[y].add(x);
            degree[x]++;
            degree[y]++;
        }
        Queue<Integer> dq = new ArrayDeque();
        for(int i = 0; i < n; i++){
            if(degree[i] == 1){
                dq.offer(i);
            }
        }
        int remainNodes = n;
        while(remainNodes > 2){
            int nodes = dq.size();
            remainNodes = remainNodes - nodes;
            for(int i = 0; i < nodes; i++){
                int cur = dq.poll();
                for(int v : adjacent[cur]){
                    degree[v]--;
                    if(degree[v] == 1){
                        dq.offer(v);
                    }
                }
            }
        }
        List<Integer> res = new ArrayList();
        while(!dq.isEmpty()){
            res.add(dq.poll());
        }
        return res;
    }
    public static int numDistinct(String s, String t) {
        //dp
        int m = s.length();
        int n = t.length();
        int[][]dp = new int[m + 1][n + 1];
        for(int i = 0; i <= m; i++){
            dp[i][0] = 1;
        }
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s.charAt(i - 1) == t.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                }else{
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[m][n];
    }
    public static int fun5(int num){
        int res = 0;
        for(int i = num; i != 0;){
            int tmp = -i;
            i = i - (tmp & i);
            res ++;
        }
        System.out.println(num + " " + res);
        return res;
    }
    public static char nextGreatestLetter(char[] letters, char target) {
        //TreeSet
        TreeSet<Character> tset = new TreeSet();
        for(char c : letters){
            tset.add(c);
        }
        Character p = tset.ceiling(target);
        if(p == null){
            return letters[0];
        }
        return p;
    }
    static boolean splitIntoFibonacci_flag = false;
    static List<Integer> splitIntoFibonacci_ans = new ArrayList();
    public static List<Integer> splitIntoFibonacci(String num) {
        List<String> res = new ArrayList();
        traceBack(res, num, 0);
        return splitIntoFibonacci_ans;
    }
    public static void traceBack(List<String> res, String num, int start){
        if(start == num.length()){
            if(isFab(res)){
                splitIntoFibonacci_flag = true;
                for(int i = 0; i < res.size(); i++){
                    splitIntoFibonacci_ans.add(Integer.valueOf(res.get(i)));
                }
                return;
            }
        }
        for(int i = start + 1; i <= num.length() && splitIntoFibonacci_flag == false; i++){
            String n = num.substring(start, i);
            res.add(n);
            if(res.size() <= 2 || isFab(res)){
                traceBack(res, num, i);
            }
            res.remove(res.size() - 1);
        }
    }
    public static boolean isFab(List<String> res){
        if(res.size() <= 2){
            return false;
        }
        String str_first = res.get(0);
        if(str_first.charAt(0) == '0' && str_first.length() != 1){
            return false;
        }
        String str_sec = res.get(1);
        if(str_sec.charAt(0) == '0' && str_sec.length() != 1){
            return false;
        }
        String first = res.get(0);
        String second = res.get(1);
        for(int i = 2; i < res.size(); i++){
            String third = res.get(i);
            if(third.charAt(0) == '0' && third.length() != 1){
                return false;
            }
            if(!third.equals(strAdd(first, second))){
                return false;
            }else{
                first = second;
                second = third;
            }
        }
        return true;
    }
    public static String strAdd(String str1, String str2){
        int flag = 0;
        int m = str1.length();
        int n  = str2.length();
        StringBuilder strBuilder = new StringBuilder();
        int i = m - 1, j = n - 1;
        for(; i >= 0 && j >= 0; j--, i--){
            int d1 = str1.charAt(i) - '0';
            int d2 = str2.charAt(j) - '0';
            // int tmp = 0;
            if(flag + d1 + d2 >= 10){
                strBuilder.insert(0, (flag + d1 + d2) - 10);
                flag = 1;
            }else{
                strBuilder.insert(0, flag + d1 + d2);
                flag = 0;
            }
        }
        while(i >= 0){
            int d1 = str1.charAt(i) - '0';
            if(flag + d1 >= 10){
                strBuilder.insert(0, (flag + d1) - 10);
                flag = 1;
            }else{
                strBuilder.insert(0, flag + d1);
                flag = 0;
            }
            i--;
        }
        while(j >= 0){
            int d2 = str2.charAt(j) - '0';
            if(flag + d2 >= 10){
                strBuilder.insert(0, (flag + d2) - 10);
                flag = 1;
            }else{
                strBuilder.insert(0, flag + d2);
                flag = 0;
            }
            j--;
        }
        if(flag == 1){
            strBuilder.insert(0, 1);
        }
        return strBuilder.toString();
    }
    public static int[][] imageSmoother(int[][] img) {
        int M = img.length;
        int N = img[0].length;
        //double[][] arr = new double[M][N + 2];
        int [][]res = new int[M][N];
        // for(int i = 0; i < M; i++){
        //     for(int j = 0; j < N; j++){
        //         arr[i + 1][j + 1] = img[i][j] / 9.0;
        //     }
        // }
        for(int i = 0; i < M; i++){
            for(int j = 0; j < N; j++){
                fun(res, img, i - 1, j - 1);
            }
        }
        return res;

    }
    public static void fun(int[][] res, int[][] img, int x, int y){
        double sum = 0;
        int s1 = x;
        int s2 = y;
        int e1 = x + 3;
        int e2 = y + 3;
        double num = 0.0;
        if(s1 < 0){
            s1 = 0;
        }
        if(e1 > img.length){
            e1 = img.length;
        }
        if(s2 < 0){
            s2 = 0;
        }
        if(e2 > img[0].length){
            e2 = img[0].length;
        }
        for(int i = s1; i < e1; i++){
            for(int j = s2; j < e2; j++){
                sum += img[i][j];
                num += 1;
            }
        }
        //int nums = (e2 - y) * (e1 - x);
        res[x + 1][y + 1] = (int) Math.floor(sum / num);
    }
    public static String longestWord_2(String[] words) {
        Set<String> set = new HashSet();

        Arrays.sort(words, new Comparator<String>(){
            public int compare(String str1, String str2){
                if(str1.length() != str2.length()){
                    return str1.length() - str2.length();
                }else{
                    return str2.compareTo(str1);
                }
            }
        });
        int[] dp = new int[words.length + 1];
        dp[0] = 0;
        set.add("");
        for(int i = 1; i < words.length + 1; i++){
            if(set.contains(words[i - 1].substring(0, words[i - 1].length() - 1)) || set.contains(words[i - 1].substring(1, words[i - 1].length()))){
                dp[i] = words[i - 1].length();
                set.add(words[i - 1]);
            }
        }
        int max = 1;
        int pos = -1;
        for(int i = 0; i < dp.length; i++){
            if(max <= dp[i]){
                max = dp[i];
                pos = i;
            }
        }
        if(pos == -1){
            return "";
        }else{
            return words[pos - 1];
        }
        // for(int i = words.length - 1; i >= 0; i--){
        //     if(fun(set, words[i].substring(0, words[i].length() - 1)) || fun(set, words[i].substring(1, words[i].length()))){
        //         return words[i];
        //     }
        // }
        // return "";
    }
    public static String longestWord(String[] words) {
        Set<String> set = new HashSet();
        for(String s : words){
            set.add(s);
        }
        Arrays.sort(words, new Comparator<String>(){
            public int compare(String str1, String str2){
                if(str1.length() != str2.length()){
                    return str1.length() - str2.length();
                }else{
                    return str2.compareTo(str1);
                }
            }
        });
        for(int i = words.length - 1; i >= 0; i--){
            if(fun(set, words[i].substring(0, words[i].length() - 1)) || fun(set, words[i].substring(1, words[i].length()))){
                return words[i];
            }
        }
        return "";
    }
    public static boolean fun(Set<String> set, String s){
        if("".equals(s)){
            return true;
        }
        if(set.contains(s)){
            return fun(set, s.substring(0, s.length() - 1)) || fun(set, s.substring(1, s.length()));
        }
        return false;
    }
    public static int networkBecomesIdle(int[][] edges, int[] patience) {
        int n = patience.length;
        int[] dist = new int[n];
        List<Integer>[] adjacent = new ArrayList[n];
        for(int i = 0; i < n; i++){
            adjacent[i] = new ArrayList();
        }
        for(int i = 0; i < edges.length; i++){
            int []edge = edges[i];
            adjacent[edge[0]].add(edge[1]);
            adjacent[edge[1]].add(edge[0]);
        }
        Deque<Integer> dq = new ArrayDeque();
        dq.offer(0);
        Set<Integer> set = new HashSet();
        while(!dq.isEmpty()){
            int start = dq.poll();
            for(int node : adjacent[start]){
                if(!set.contains(node)){
                    set.add(node);
                    dq.offer(node);
                    dist[node] = dist[start] + 1;
                }
            }
        }
        int res = 0;
        for(int i = 1; i < n; i++){
            if(patience[i] < dist[i] * 2){
                int distance = dist[i] * 2;
                res = Math.max(res, (distance - 1) / patience[i] * patience[i] + distance);
            }
        }
        return res;
    }
    public static String[] findRestaurant(String[] list1, String[] list2) {
        Map<String, Integer> map = new HashMap();
        for(int i = 0; i < list1.length; i++){
            map.put(list1[i], i);
        }
        ArrayDeque<int[]> dq = new ArrayDeque();
        for(int i = 0; i < list2.length; i++){
            if(map.containsKey(list2[i])){
                int index = map.get(list2[i]);
                if(dq.isEmpty()){
                    dq.push(new int[]{index, i});
                }else{
                    boolean flag = false;
                    while(!dq.isEmpty()){
                        int[] topElement = dq.peek();
                        if(index + i < topElement[0] + topElement[1]){
                            dq.pop();

                        }else if(index + i == topElement[0] + topElement[1]){
                            break;
                        }else{
                            flag = true;
                            break;
                        }
                    }
                    if(flag == false){
                        dq.push(new int[]{index, i});
                    }
                }
            }
        }
        String[] res = new String[dq.size()];
        int i = 0;
        while(!dq.isEmpty()){
            int[] ind = dq.pop();
            res[i++] = list1[ind[0]];
        }
        return res;
    }
    public static boolean validUtf8(int[] data) {
        for(int i = 0; i < data.length;){
            int j = fun_validUtf8(data[i]);
            if(j == 0){
                i = i + 1;
            }else{
                if (!isValid2(i + 1, i + j - 1, data)){
                    return false;
                }else{
                    i += j;
                }
            }
        }
        return true;
    }
    public static int fun_validUtf8(int num){//1
        int j = 0;
        for(int i = 7; i >= 0; i--){
            if(((num >> i) & 1) == 1){
                j++;
            }else{
                break;
            }
        }
        return j;
    }
    public static boolean isValid(int num){
        if(((num >> 7) & 1) != 1){
            return false;
        }
        if(((num >> 6) & 1) != 0){
            return false;
        }
        return true;
    }
    public static boolean isValid2(int start, int end, int[] data){
        if(start > end || end >= data.length){
            return false;
        }
        for(int i = start; i <= end; i++){
            if(!isValid(data[i])){
                return false;
            }
        }
        return true;
    }
    public void tamplate_t(){
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        for(int i = 0; i < 1; i++){
            fun();
        }
    }
    public void tamplate(){
        fun();
    }
    public static void my_main2(){
        System.out.println("hello");
    }
    public static void my_main3(){
        System.out.println("hello");
    }
    public static void my_main4(){
        System.out.println("hello");
    }
    public static void fun1(){
        int m = 4;
        int res = 0;
        int [][]items = new int[][]{{0, 1},{1,2},{2,3},{}};
        int [][]dp = new int[m + 1][2];
        for (int j = 1;j < m;j++){
            if (dp[res][1] < items[j][1]) dp[++res] = items[j];
            else if (dp[res][1] > items[j][1]){
                int l = 1,r = res,pos = 0;
                while (l <= r){
                    int mid = (l + r) >> 1;
                    if (dp[mid][1] < items[j][1]){
                        pos = mid;
                        l = mid + 1;
                    }else{
                        r = mid - 1;
                    }
                }
                if (dp[pos][0] != items[j][0]) dp[pos + 1] = items[j];
            }
        }
    }
    public static void fun(){
        Scanner in = new Scanner(System.in);
        String str = in.nextLine();
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < str.length(); i++){
            if(str.charAt(i) == '<' || str.charAt(i) == '=' || str.charAt(i) == '>'){
                sb.append(" ");
                sb.append(str.charAt(i));
                sb.append(" ");
            }else if(str.charAt(i) == ' '){
                continue;
            }else{
                sb.append(str.charAt(i));
            }
        }
        System.out.println(sb.toString());
    }
    public static void my_main1() {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        for(int i = 0; i < t; i++){
            int k = sc.nextInt();
            int l = sc.nextInt();
            String str = sc.next();

            if(isFun(str)){
                System.out.println(1);
            }
            String resStr = reverse(str);
            StringBuilder stringB = new StringBuilder();
//             Set<String> set = new HashSet();
            ArrayDeque<String> dq = new ArrayDeque();
//             set.add(str);
            dq.offer(str);
            int res = 0;
            while(!dq.isEmpty() && k > 0){
                String tmp = dq.poll();
                String reverse_tmp = reverse(tmp);
                String str_add1 = tmp + reverse_tmp;
                String str_add2 = reverse_tmp + tmp;
                k--;
                if(isFun(str_add1)){
                    res++;
                }else{
                    dq.offer(str_add1);
                }

                if(isFun(str_add2)){
                    res++;
                }else{
                    dq.offer(str_add2);
                }
            }
            System.out.println(res);
        }

    }
    public static String reverse(String s){
        char[] chs = new char[s.length()];
        for(int i = s.length() - 1, j = 0; i >= 0; i--,j++){
            chs[j] = s.charAt(i);
        }
        return new String(chs);
    }
    public static boolean isFun(String s){
//         char[] chs = new char[s.length()];

        for(int i = s.length() - 1, j = 0; i < j ; i--,j++){

            if(s.charAt(i) != s.charAt(j)){
                return false;
            }
        }
        return true;
    }
    static int my_main_res = 0;
    public static void fun(Map<Integer, Integer> map, int k, int[] arr){
        if(!map.containsKey(k)){
            return;
        }
        if(map.get(k) != 1){
            int times = map.get(k);
            map.put(k, 1);
            int new_key = k + 1;
            my_main_res++;

            fun(map, new_key, arr);
        }
    }
    public static void my_main() {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i < n; i++) {// while
            arr[i] = in.nextInt();
        }
        Arrays.sort(arr);
        Map<Integer, Integer> map = new HashMap();
        for(int i = 0; i < n; i++){
            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
        }
        for(int i = 0; i < n; i++){
            fun(map, arr[i], arr);
        }
        System.out.println(res);
    }
    public static String nearestPalindromic(String n) {
        Long selfValue = Long.valueOf(n);
        PriorityQueue<Long> pq = new PriorityQueue(new Comparator<Long>(){
            public int compare(Long a, Long b){
                long dis1 = Math.abs(a - selfValue);
                long dis2 = Math.abs(b - selfValue);
                if(dis1 < dis2){
                    return -1;
                }else if(dis1 == dis2){
                    if(a < b){
                        return -1;
                    }else{
                        return 1;
                    }
                }else{
                    return 1;
                }
            }
        });
        int len = (n.length() + 1 ) / 2;
        String preffix = n.substring(0, len);
        int start = Integer.valueOf(preffix);

        for(int i = start - 1; i <= start + 1; i++){
            StringBuilder sb = new StringBuilder();
            sb.append(String.valueOf(i));
            StringBuffer stringBuffer = new StringBuffer(String.valueOf(i));
            String tmp = stringBuffer.reverse().toString();
            String tmp2 = tmp.substring(n.length() & 1);
            sb.append(tmp2);
            long l = Long.valueOf(sb.toString());
            pq.offer(l);
        }
        pq.offer((long)(Math.pow(10, n.length() - 1) - 1));
        pq.offer((long)(Math.pow(10, n.length()) + 1));
        // Long selfValue = Long.valueOf(n);
        long res = pq.poll();
        if(res == selfValue){
            return String.valueOf(pq.poll());
        }else{
            return String.valueOf(res);
        }
    }
    public static int second_compareVersion(String version1, String version2) {

        String[] strs1 = version1.split("\\.");
        String[] strs2 = version2.split("\\.");
        int i;
        for(i = 0; i < strs1.length && i < strs2.length; i++){
            int nums1 = Integer.valueOf(strs1[i]);
            System.out.println(nums1);
            int nums2 = Integer.valueOf(strs2[i]);
            System.out.println(nums2);
            if(nums1 < nums2){
                return -1;
            }else if(nums1 > nums2){
                return 1;
            }
        }
        while(i < strs1.length){
            if(Integer.valueOf(strs1[i]) > 0){
                return 1;
            }
            i++;
        }
        while(i < strs2.length){
            if(Integer.valueOf(strs2[i]) > 0){
                return -1;
            }
            i++;
        }
        return 0;
    }
    public static String convert(String s, int numRows) {
        // List<Character>[] list = new ArrayList[numRows]; //
        int n = s.length();
        char[][] arr = new char[numRows][n];
        int len_dir = numRows * 2 - 2;
        int[][] dirs = new int[len_dir][2];
        for(int i = 0; i < numRows - 1; i++){//
            dirs[i][0] = 1;
            dirs[i][1] = 0;
        }
        for(int i = numRows - 1; i < len_dir; i++){
            dirs[i][0] = -1;
            dirs[i][1] = 1;
        }
        int x = 0;
        int y = 0;
        arr[x][y] = s.charAt(0);
        for(int i = 1; i < n;){
            for(int[] dir : dirs){
                x += dir[0];
                y += dir[1];
                if(i >= n){
                    break;
                }
                arr[x][y] = s.charAt(i++);
            }
        }
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < numRows; i++){
            for(int j = 0; j < n; j++ ){
                if(arr[i][j] != 0){
                    sb.append(arr[i][j]);
                }
            }
        }
        return sb.toString();
    }
    public static int lengthOfLIS(int[] nums) {
        //dp
        //
        int n = nums.length;
        int[] dp = new int[n];
        for(int i = 0; i < n; i++){
            dp[i] = 1;
        }
        for(int i = n - 2; i >= 0; i--){
            for(int j = i + 1; j < n; j++){
                if(nums[i] < nums[j]){
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
                }
            }
        }
        int max = 0;
        for(int i = 0; i < n; i++){
            max = Math.max(dp[i], max);
        }
        return max;
    }
    static class LRUCache {
        int n;
        int last = 0;
        TreeMap< Long, Integer> tm;//{time_stamp, key}
        Map<Integer, long[]> map;//{time_stamp, value}
        public LRUCache(int capacity) {
            n = capacity;
            tm = new TreeMap();
            map = new HashMap();
        }

        public int get(int key) {
            if(map.containsKey(key)){
                long[] tmp_long = map.get(key);
                tm.remove(tmp_long[0]);
                tmp_long[0] = System.currentTimeMillis() * 1000 + System.nanoTime();
                tm.put(tmp_long[0], key);
                map.put(key, tmp_long);
                return (int)tmp_long[1];//value
            }
            return -1;
        }

        public void put(int key, int value) {
            if(map.containsKey(key)){
                long[] tmp_long = map.get(key);//{time_stamp, value}
                tm.remove(tmp_long[0]);
                tmp_long[0] = System.currentTimeMillis() * 1000 + System.nanoTime();
                tmp_long[1] = value;
                tm.put(tmp_long[0], key);
                map.put(key, tmp_long);
            }else{
                if(map.size() < n){
                    long[] tmp_long = new long[]{System.currentTimeMillis() * 1000 + System.nanoTime(), value};
                    map.put(key, tmp_long);
                    tm.put(tmp_long[0], key);
                }else{
                    Map.Entry tmp_en = tm.firstEntry();
                    long time_stamp = (long)tmp_en.getKey();
                    int k = (int)tmp_en.getValue();
                    tm.remove(time_stamp);
                    map.remove(k);

                    long[] tmp_long = new long[]{System.currentTimeMillis() * 1000 + System.nanoTime(), value};

                    map.put(key, tmp_long);
                    tm.put(tmp_long[0], key);
                }
            }

        }
    }
    public static int[] findBall(int[][] grid) {
        //
        m = grid.length;
        n = grid[0].length;
        int[] res = new int[n];
        for(int i = 0; i < n; i++){
            res[i] = fall(grid, 0, i, m, n);
        }
        return res;
    }
    public static int fall(int[][] grid, int x, int y, int m, int n){
        if(x == m){
            return y;
        }
        if(y < 0 || y >= n){
            return -1;
        }
        if(y + 1 >= n && grid[x][y] == 1){//
            return -1;
        }
        if(y - 1 < 0 && grid[x][y] == -1){//
            return -1;
        }
        if(y + 1 < n && grid[x][y] == 1 &&  grid[x][y + 1] == -1){//
            return -1;
        }
        if(y - 1 >= 0 && grid[x][y - 1] == 1 &&  grid[x][y] == -1){
            return -1;
        }
        y = y + grid[x][y];
        return fall(grid, x + 1, y, m, n);
    }
    public static boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {
        int n = blocked.length;
        if(n < 2){
            return true;
        }
        int source_state = isClosed(source, n, target, blocked);
        if(source_state == 1){
            return true;
        }else if(source_state == 0){
            return false;
        }else{
            int target_state = isClosed(target, n, source, blocked);
            if(target_state == 1){
                return true;
            }else{
                return target_state != 0;
            }
        }
    }
    public static int isClosed(int[] source, int n, int[] target, int[][] blocked){
//        List<String> list = new ArrayList<>();
        Deque<String> dq = new ArrayDeque();
        dq.offer(source[0] + "#" + source[1]);
//        list.add(source[0] + "#" + source[1]);

        int count = n * (n - 1) / 2;
        Set<String> set = new HashSet();
        set.add("0#0");
        Set<String> setBlocked = new HashSet();
        for(int[] pos : blocked){
            String n_pos = pos[0] + "#" + pos[1];
            setBlocked.add(n_pos);
        }
        while(!dq.isEmpty() && count > 0){
            String coordinate = dq.poll();
            String[] s = coordinate.split("#");
            int x = Integer.valueOf(s[0]);
            int y = Integer.valueOf(s[1]);

            for(int []dir : dirs){
                int nx = dir[0] + x;
                int ny = dir[1] + y;
                String n_c = nx + "#" + ny;
                if(nx == target[0] && ny == target[1]){
                    return 1;
                }
                if(nx < 0 || ny < 0 || set.contains(n_c) || setBlocked.contains(n_c)){//block[]
                    continue;
                }
                set.add(n_c);
                count--;
                dq.offer(n_c);
//                list.add(n_c);
            }
        }
//        Map<String, Integer> map = new HashMap<>();
//        for(int i = 0; i < list.size(); i++){
//            if(map.containsKey(list.get(i))){
//                System.out.println(list.get(i));
//            }else{
//                map.put(list.get(i), 1);
//            }
//        }

        if(dq.isEmpty()){
            return 0;
        }else{
            return -1;
        }
    }
    public static String pushDominoes(String dominoes) {
        //bfs
        List<int[]> queue = new ArrayList();
        char[] res = new char[dominoes.length()];
        int [] ans = new int[dominoes.length()];
        for(int i = 0; i < dominoes.length(); i++){
            if(dominoes.charAt(i) == 'L'){
                queue.add(new int[]{i, -1});
                res[i] = dominoes.charAt(i);
            }
            if(dominoes.charAt(i) == 'R'){
                queue.add(new int[]{i, 1});
                res[i] = dominoes.charAt(i);
            }
        }
        // int k = 0;
        for(int i = 0; i < queue.size(); i++){
            int []tmp = queue.get(i);
            if(tmp[1] > 0){
                if(tmp[0] + tmp[1] > dominoes.length()){
                    continue;
                }
                if(ans[tmp[0] + tmp[1]] == 0){
                    ans[tmp[0] + tmp[1]] = tmp[1];
                    tmp[1]++;
                    queue.add(tmp);
                }else{
                    if(Math.abs(ans[tmp[0] + tmp[1]]) == Math.abs(tmp[1])){
                        ans[ans[tmp[0] + tmp[1]]] = Integer.MIN_VALUE;
                    }
                }
            }
            if(tmp[1] < 0){
                if( tmp[0] + tmp[1] < 0 ){
                    continue;
                }
                if( ans[tmp[0] + tmp[1]] == 0){
                    ans[tmp[0] + tmp[1]] = tmp[1];
                    tmp[1]--;
                    queue.add(tmp);
                }else{
                    if(Math.abs(ans[tmp[0] + tmp[1]]) == Math.abs(tmp[1])){
                        ans[tmp[0] + tmp[1]] = Integer.MIN_VALUE;
                    }
                }
            }
        }
        for(int i = 0; i < dominoes.length(); i++){
            if(dominoes.charAt(i) == 'R' || dominoes.charAt(i) == 'L'){
                res[i] = dominoes.charAt(i);
            }else{
                if(ans[i] == Integer.MIN_VALUE || ans[i] == 0){
                    res[i] = '.';
                }else{
                    if(ans[i] > 0){
                        res[i] = 'R';
                    }else{
                        res[i] = 'L';
                    }
                }
            }
        }
        return new String(res);
    }
    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode L = root;
        List<TreeNode> path_p = lowestCommonAncestor_fun(root, p);
        List<TreeNode> path_q = lowestCommonAncestor_fun(L, q);
        TreeNode node = null;
        for(int i = 0;  i < path_p.size() && i < path_q.size(); i++){
            if(path_p.get(i) != path_q.get(i)){
                return node;
            }
            node = path_p.get(i);
        }
        return node;
    }
    public static List<TreeNode> lowestCommonAncestor_fun(TreeNode root, TreeNode target){
        List<TreeNode> path = new ArrayList();
        while(root != null){
            path.add(root);
            if(root.value == target.value){
                return path;
            }else if(root.value > target.value){
                root = root.left;
            }else{
                root = root.right;
            }
        }
        return path;
    }
    static int len = 0;
    public static List<String> restoreIpAddresses(String s) {
        len = s.length();
        List<String> res = new ArrayList();
        StringBuilder sb = new StringBuilder();
        int[] strs = new int[4];
        dfs(s, res, strs, 0, 0);
        return res;
    }
    public static void dfs(String s, List<String> res, int[] strs, int i, int k){
        if(i >= len && k == 4){
            StringBuilder tmp_s = new StringBuilder();
            for(int z = 0; z < 3; z++){
                tmp_s.append(strs[z]);
                tmp_s.append(".");
            }
            tmp_s.append(strs[3]);
            res.add(tmp_s.toString());
            return;
        }
        if(k == 4){
            return;
        }
        if(i == s.length()){
            return;
        }
        int addr = 0;
        for(int j = i; j < len; j++){
            addr = addr * 10 + s.charAt(j) - '0';
            if(addr <= 255){
                strs[k] = addr;
                dfs(s, res, strs, j + 1, k + 1);
            }else{
                break;
            }
        }
    }
    static int knightProbability_possible  = 0;
    static int [][]knightProbability_dirs = new int[][]{{-2, 1},{-2, -1},{-1, -2},{1, -2},{2, -1},{2, 1},{1, 2},{-1, 2}};
    static int knightProbability_n;
    public static double knightProbability(int _n, int k, int row, int column) {
        int total = (int)Math.pow(8, k);
        knightProbability_n = _n;
        for(int[] dir : knightProbability_dirs){
            int x = dir[0] + row;
            int y = dir[1] + column;
            dfs(x, y, k - 1);
        }
        return (double)knightProbability_possible / (double)total;
    }
    public static void dfs(int i, int j, int k){
        if(i < 0 || i >= knightProbability_n || j < 0 || j >= knightProbability_n){
            return ;
        }
        if(k == 0){
            knightProbability_possible++;
            return;
        }
        for(int[] dir : knightProbability_dirs){
            int x = dir[0] + i;
            int y = dir[1] + j;
            dfs(x, y, k - 1);
        }
    }
    public static boolean isStraight(int[] nums){
        int []set = new int[14];
        int max = 0;
        int min = Integer.MAX_VALUE;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] != 0){
                if(set[nums[i]] != 0){
                    return false;
                }
                set[nums[i]]++;
                max = Math.max(max, nums[i]);
                min = Math.min(min, nums[i]);

            }else{
                set[nums[i]]++;
            }

        }
        int bound = max - min + 1;
        if(bound == 5){
            return true;
        }else{
            return false;
        }
    }
    public static int[][] findContinuousSequence(int target) {
        //
        List<int[]> list = new ArrayList();
        for(int i = 1,j = 2; i < j;){
            int sum = (i + j) * (j - i + 1) / 2;
            if(sum == target){
                int[] res = fun(i, j);
                list.add(res);
                i++;
            }else if(sum < target){
                j++;
            }else{
                i++;
            }
        }
        return list.toArray(new int[list.size()][]);
    }
    public static int[] fun(int i, int j){
        int []res = new int[j - i + 1];
        for(int k = 0; k < j - i + 1; k++){
            res[k] = i + k;
        }
        return res;
    }
    public static String minNumber(int[] nums) {
        StringBuilder sb = new StringBuilder();
        // PriorityQueue<String> pq = new PriorityQueue();
        String[] n = new String[nums.length];
        for(int i = 0; i < nums.length; i++){
            n[i] = nums[i] + "";
        }
        Arrays.sort(n, new Comparator<String>(){
            public int compare(String a, String b){
                int i;
                for(i = 0; i < a.length() && i < b.length(); i++){
                    if(a.charAt(i) - b.charAt(i) != 0){
                        return a.charAt(i) - b.charAt(i);
                    }
                }
                int j = i - 1;
                for(;j < b.length(); j++){
                    if(a.charAt(i) - b.charAt(j) != 0){
                        return a.charAt(i) - b.charAt(j);
                    }
                }
                for(;j < a.length(); j++){
                    if(a.charAt(j) - b.charAt(i) != 0){
                        return a.charAt(j) - b.charAt(i);
                    }
                }
                return 1;
            }
        });
        for(String s : n){
            sb.append(s);
        }
        return sb.toString();
    }
    public static int[] gridIllumination(int n, int[][] lamps, int[][] queries) {
        int []ans = new int[queries.length];
        Set<Long> set = new HashSet();
        Map<Integer, Integer> row = new HashMap();
        Map<Integer, Integer> column = new HashMap();
        Map<Integer, Integer> diagonal = new HashMap();
        Map<Integer, Integer> dis_diagonal = new HashMap();
        int[][] dirs = new int[][]{{0,0},{-1,0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1},{-1, 1}, {1, -1}, {1, 1}};
        for(int []element : lamps){
            int x = element[0];
            int y = element[1];
            set.add((long)x * (long)n + (long)y);
            row.put(x, row.getOrDefault(x, 0) + 1);
            column.put(y, column.getOrDefault(y, 0) + 1);
            diagonal.put(x + y, diagonal.getOrDefault(x + y, 0) + 1);
            dis_diagonal.put(x - y, dis_diagonal.getOrDefault(x - y, 0) + 1);
        }
        for(int i = 0; i < queries.length; i++){
            int x = queries[i][0];
            int y = queries[i][1];
            if(row.containsKey(x) || column.containsKey(y) || diagonal.containsKey(x + y) || dis_diagonal.containsKey(x - y)){
                ans[i] = 1;
                for(int[] dir : dirs){
                    int tmp_x = dir[0] + x;
                    int tmp_y = dir[1] + y;
                    if(tmp_x < 0 || tmp_x >= n || tmp_y < 0 || tmp_y >= n) {
                        continue;
                    }
                    long tmp = (long)tmp_x * (long)n + (long)tmp_y;
                    if(set.contains(tmp)){
                        set.remove((long)tmp_x * (long)n + (long)tmp_y);
                        if(row.get(tmp_x) == 1){
                            row.remove(tmp_x);
                        }else{
                            row.put(tmp_x, row.get(tmp_x) - 1);
                        }

                        if(column.get(tmp_y) == 1){
                            column.remove(tmp_y);
                        }else{
                            column.put(tmp_y, column.get(tmp_y) - 1);
                        }

                        if(diagonal.get(tmp_x + tmp_y) == 1){
                            diagonal.remove(tmp_x + tmp_y);
                        }else{
                            diagonal.put(tmp_x + tmp_y, diagonal.get(tmp_x + tmp_y) - 1);
                        }

                        if(dis_diagonal.get(tmp_x - tmp_y) == 1){
                            dis_diagonal.remove(tmp_x - tmp_y);
                        }else{
                            dis_diagonal.put(tmp_x - tmp_y, dis_diagonal.get(tmp_x - tmp_y) - 1);
                        }
                    }
                }
            }
        }
        return ans;
    }
    public static boolean verifyPostorder(int[] postorder) {
        return recur(postorder, 0, postorder.length - 1);
    }
    public static boolean recur(int[] postorder, int i, int j){
        if(i >= j){
            return true;
        }
        int x = i;
        while(postorder[x] < postorder[j]){
            x++;
        }
        int m = x;
        while(postorder[x] > postorder[j]){
            x++;
        }
        return x == j && recur(postorder, i, m - 1) && recur(postorder, m , j - 1);
    }
//    static int[] reversePairs_res;
    static int reversePairsInt_res = 0;
    public static int reversePairs(int[] nums) {
        int n = nums.length;

        fun(nums, 0, (n - 1) / 2, (n - 1) / 2 + 1, n - 1);
        return reversePairsInt_res;
    }
    public static void fun(int[] nums, int s1, int e1, int s2, int e2){

        if(s1 <= e1 && s2 <= e2){
            fun(nums, s1, (e1 - s1)/2 + s1, (e1 - s1)/2 + s1 + 1, e1);
            fun(nums, s2, (e2 - s2)/2 + s2, (e2 - s2)/2 + s2 + 1, e2);
            int [] reversePairs_res = new int[nums.length];
            System.arraycopy(nums, 0,reversePairs_res,0, nums.length);
            int i = s1;
            int j = s2;
            int k = s1;
            while(i <= e1 && j <= e2){
                if(reversePairs_res[i] < reversePairs_res[j]){
                    nums[k++] = reversePairs_res[i++];
                }else{
                    reversePairsInt_res += e1 - i + 1;
                    nums[k++] = reversePairs_res[j++];
                }
            }
            while(i <= e1){
                nums[k++] = reversePairs_res[i++];
            }
            while(j <= e2){
                nums[k++] = reversePairs_res[i++];
            }
        }
    }
    static StringBuilder sb = new StringBuilder();
    static Map<String, Integer> map = new HashMap();
    // StringBuilder sb_in = new StringBuilder();
    // Encodes a tree to a single string.
    public static void preOrder(TreeNode root){
        if(root != null){
            sb.append(root.value + "_");
            preOrder(root.left);
            preOrder(root.right);
        }
    }
    public static void inOrder(TreeNode root){
        if(root != null){
            inOrder(root.left);
            sb.append(root.value + "_");
            inOrder(root.right);
        }
    }
    public static String serialize(TreeNode root) {
        preOrder(root);
        sb.append("#");
        inOrder(root);
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public static TreeNode deserialize(String data) {
        if("#".equals(data)) return null;
        String []strs = data.split("#");
        String[] preArray = strs[0].split("_");
        String[] inArray = strs[1].split("_");
        int len = preArray.length;
        for(int i = 0; i < len; i++){
            map.put(inArray[i], i);
        }
        TreeNode root = createTree(preArray, 0, len - 1, inArray, 0, len - 1);
        return root;
    }
    public static TreeNode createTree(String[] preArray, int s1, int e1, String[] inArray, int s2, int e2){
        if(s1 > e1){
            return null;
        }
        // int n = preArray.length;
        int val = Integer.valueOf(preArray[s1]);
        TreeNode root = new TreeNode(val, null, null);
        int pos = map.get(preArray[s1]);
        int len = pos - s2;
        TreeNode left = createTree(preArray, s1 + 1, s1 + len, inArray, s2, pos - 1);
        TreeNode right = createTree(preArray, s1 + len + 1, e1, inArray, pos + 1, e2);
        root.left = left;
        root.right = right;
        return root;
    }
    public static int findNthDigit(int n) {
        if(n < 10) return n;
        long _n = n;
        int []flag = new int[]{10, 190, 2890, 38890, 488890, 5888890, 68888890, 788888890};
        Map<Integer, Long> map = new HashMap();
        map.put(0, 0l);
        map.put(1, 10l);
        map.put(2, 190l);
        map.put(3, 2890l);
        map.put(4, 38890l);
        map.put(5, 488890l);
        map.put(6, 5888890l);
        map.put(7, 68888890l);
        map.put(8, 788888890l);
        map.put(9, 8888888890l);
        map.put(10, 98888888890l);
        // long sum = 0;
        // for(long i = 10, j = 0; i <= 10000000000l; i *= 10){
        //     String s = String.valueOf(i);
        //     long len = s.length();
        //     sum += (len - 1) * (i - j);
        //     System.out.println(sum);
        //     j = i;
        // }
        int k;
        _n += 1;
        for(k = 1; k <= 10; k++){
            if(_n < map.get(k)){
                _n -= map.get(k - 1);
                break;
            }
        }
        long num = (long)Math.pow(10, k-1) - 1;
        long offset = _n / k;
        if(_n % k != 0){
            num += 1;
        }
        num = num + (_n / k);
        String s = String.valueOf(num);
        int len = s.length();
        return s.charAt((int)(_n % k + len - 1) % k) - '0';
    }
    public static int countDigitOne_1(int n) {
        //1
        //
        int res = 0;
        String s = String.valueOf(n);
        int len = s.length();
        for(int i = 0; i < len; i++){
            int x = s.charAt(i) - '0';
            int pre = preffix(s, i);
            int su = suffix(s, i);
            if(x == 0){

            }else if(x == 1){
                res += su + 1;
                res += pre * Math.pow(10, len - i - 1);
            }else{
                res += Math.pow(10, len - i - 1);
                res += pre * Math.pow(10, len - i - 1);
            }
        }
        return res;
    }
    public static int preffix(String s, int i){
        int res = 0;
        for(int j = 0; j < i; j++){
            res = res * 10 + s.charAt(j) - '0';
        }
        return res;
    }
    public static int suffix(String s, int i){
        String ss = s.substring(i+1);
        if(ss.length() == 0){
            return 0;
        }
        return Integer.parseInt(ss);
    }
    static Set<Integer> set = new HashSet();
    static Deque<Integer> dq = new ArrayDeque();
    static int j = 0;
    static int i = 0;
    public static void push(int[] pushed, int[] popped){
        for(; i < pushed.length;){
            if(pushed[i] == popped[j]){
                i++;
                j++;
                break;
            }else{
                dq.push(pushed[i]);
                set.add(pushed[i]);
                i++;
            }
        }
    }
    public static int pop(){
        return dq.pop();
    }
    public static boolean validateStackSequences(int[] pushed, int[] popped) {
        boolean flag = true;
        while(true){
            if(!set.contains(popped[j])){
                push(pushed, popped);
            }else{
                if(pop() != popped[j]){
                    return false;
                }else{
                    j++;
                }
            }
            if(j == popped.length){
                break;
            }
        }
        return true;
    }
    public static int[] spiralOrder(int[][] matrix) {
        //https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/
        int []res = new int[matrix.length * matrix[0].length];
        int l = 0;
        int r = matrix[0].length - 1;
        int top = 0;
        int bottom = matrix.length - 1;
        int k = 0;
        while(true){
            for(int i = l; i <= r; i++){
                res[k++] = matrix[top][i];
            }
            top++;
            if(top > bottom || l > r){
                break;
            }
            for(int i = top; i <= bottom; i++){
                res[k++] = matrix[i][r];
            }
            r--;
            if(top < bottom || l > r){
                break;
            }
            for(int i = r; i >= l; i--){
                res[k++] = matrix[bottom][i];
            }
            bottom--;
            if(top < bottom || l > r){
                break;
            }
            for(int i = bottom; i >= top; i--){
                res[k++] = matrix[i][l];
            }
            l++;

            if(top < bottom || l > r){
                break;
            }
        }
        return res;
    }
    public static boolean isSymmetric_fun(TreeNode L, TreeNode R){
        if(L == null && R == null) return true;
        else if(L == null || R == null || L.val != R.val){
            return false;
        }else{
            return isSymmetric_fun(L.left, R.right) && isSymmetric_fun(L.right, R.left);
        }
    }
    public static boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return isSymmetric_fun(root.left, root.right);
    }

    public static boolean fun(TreeNode A, TreeNode B){
        if(B == null) return true;
        if(A == null) return false;
        if(A.value == B.value){
            return fun(A.left, B.left) && fun(A.right, B.right);
        }else{
            return fun(A.left, B) || fun(A.right, B);
        }
    }
    public static boolean isSubStructure(TreeNode A, TreeNode B) {
        if(A == null || B == null) return false;
        return fun(A, B);
    }
    public static int secondMinimum(int n, int[][] edges, int time, int change) {
        List<Integer>[] graph = new ArrayList[n + 1];
        for(int i = 0; i <= n; i++){
            graph[i] = new ArrayList();
        }
        for(int i = 0; i < edges.length; i++){
            graph[edges[i][0]].add(edges[i][1]);
            graph[edges[i][1]].add(edges[i][0]);
        }
        int[] arr = new int[]{1, 0};
        int[][] path = new int[n + 1][2];

        for(int i = 0; i <= n;i++){
            Arrays.fill(path[i], 100000);
        }
        path[1][0] = 0;

        Queue<int[]> queue = new ArrayDeque();
        queue.add(arr);
        // int len = 0;
        while(!queue.isEmpty()){
            int []tmp = queue.poll();
            int cur = tmp[0];
            int len =tmp[1];
            for(int v : graph[cur]){
                if(len + 1 < path[v][0]){
                    path[v][0] = len + 1 ;
                    queue.add(new int[]{v, len + 1});
                }else if(len + 1 > path[v][0] && len + 1 < path[v][1]){
                    path[v][1] = len + 1;
                    queue.offer(new int[]{v, len + 1});
                }
            }
        }
        int res = 0;
        for(int i = 0; i < path[n][1]; i++){
            if(i * time % (change * 2) >= change){
                res += change * 2 - i * time % (change * 2);
            }
            res += time;
        }
        return res;
    }
    static int movingCount_res = 0;
    public static int movingCount(int m, int n, int k) {
        Integer res = 0;
        boolean [][]visited = new boolean[m][n];
        dfs(0, 0, m, n, k, res, visited);
        return movingCount_res;
    }
    public static void dfs(int x, int y, int m,int n, int k, Integer res, boolean[][]visited){
        if(x < 0 || x > m - 1 || y < 0 || y > n - 1 || visited[x][y] || !isValid(x, y, k)){
            return;
        }
        // if(isValid(x, y, k)){
        movingCount_res++;
        // }
        visited[x][y] = true;
        dfs(x + 1, y, m, n, k, res, visited);
        dfs(x , y + 1, m, n, k, res, visited);
        // visited[x][y] = false;
    }
    public static boolean isValid(int x, int y, int k){
        int a1 = addBits(x);
        int a2 = addBits(y);
        return a1 + a2 > k ? false : true;
    }
    public static int addBits(int n){
        int res = 0;
        while(n != 0){
            res += n % 10;
            n = n / 10;
        }
        return res;
    }
    public static boolean exist(char[][] board, String word) {
        boolean[][] visited = new boolean[board.length][board[0].length];
        return dfs(board, word, 0, 0, 0, visited);
    }
    public static boolean dfs(char[][] board, String word, int x, int y, int i, boolean[][]visited){
        if(word.length() == i){
            return true;
        }
        // if(x < 0 || x >= board.length){
        //     return false;
        // }
        // if(y < 0 || y >=board[0].length){
        //     return false;
        // }
        if(word.charAt(i) == board[x][y] && !visited[x][y] ){
            if(x + 1 < visited.length){
                visited[x][y] = true;
                boolean res1 = dfs(board, word, x + 1, y, i + 1, visited);
                visited[x][y] = false;
                if(res1){
                    return true;
                }
            }
            if(x - 1 >= 0){
                visited[x][y] = true;
                boolean res2 = dfs(board, word, x - 1, y, i + 1, visited);
                visited[x][y] = false;
                if(res2){
                    return true;
                }
            }
            if(y + 1 < visited[0].length){
                visited[x][y] = true;
                boolean res3 = dfs(board, word, x, y + 1, i + 1, visited);
                visited[x][y] = false;
                if(res3){
                    return true;
                }
            }
            if(y - 1 >= 0){
                visited[x][y] = true;
                boolean res4 = dfs(board, word, x, y - 1, i + 1, visited);
                visited[x][y] = false;
                if(res4){
                    return true;
                }
            }
            return false;
        }else{
            return false;
        }
    }
    public static int minJumps(int[] arr) {
        Map<Integer, List<Integer>> map = new HashMap();
        for(int i = 0; i < arr.length; i++){
            map.putIfAbsent(arr[i], new ArrayList<Integer>());
            map.get(arr[i]).add(i);
        }
        Deque<int[]> q = new ArrayDeque();
        Set<Integer> set = new HashSet();
        q.offer(new int[]{0, 0});
        set.add(0);
        int step = 0;
        while(!q.isEmpty()){
            int []tmp = q.poll();
            int index = tmp[0];
            step = tmp[1];
            if(index == arr.length - 1){
                return step;
            }
            if(map.containsKey(arr[index])){
                for(int v : map.get(arr[index])){
                    if(set.add(v)){
                        q.offer(new int[]{v, step + 1});
                    }
                }
                map.remove(arr[index]);
            }
            if(index + 1 < arr.length && set.add(index + 1)){
                q.offer(new int[]{index + 1, step+1});
            }
            if(index - 1 >= 0 && set.add(index - 1)){
                q.offer(new int[]{index - 1, step+1});
            }
        }
        return -1;
    }
    public static int findMinDifference(List<String> timePoints) {
        Collections.sort(timePoints, new Comparator<String>(){
            public int compare(String a, String b){
                return a.compareTo(b);
            }
        });
        int min = 12 * 60;
        int n = timePoints.size();
        for(int i = 0; i < timePoints.size(); i++){
            min = Math.min(min, dis(timePoints.get(i), timePoints.get((i + 1) % n)));
        }
        return min;
    }
    public static int dis(String time1, String time2){
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < time1.length(); i++){
            if(time1.charAt(i) == ':'){
                sb.append(":");
            }else{
                sb.append(Math.abs(time2.charAt(i) - time1.charAt(i)) + '0');
            }
        }
        String  []s = sb.toString().split(":");
        int hour = Integer.valueOf(s[0]);
        int minutes = Integer.valueOf(s[1]);
        int res = hour * 60 + minutes;
        res = 12 * 60 > res ? res : 12 * 60 - res;
        return res;
    }
    public static List<List<Integer>> threeSum(int[] nums) {
        if(nums.length < 3){
            return new ArrayList<List<Integer>>();
        }
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList();
        // boolean[] visited = new boolean[nums.length];
        // traceBack(nums,res, new ArrayList<Integer>(), 0, 0);
        List<Integer> list_tmp = null;
        for(int i = 0; i < nums.length; i++){
            if(i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            int target = 0 - nums[i];
            list_tmp = new ArrayList();
            list_tmp.add(nums[i]);
            for(int j = i + 1, k = nums.length - 1; j < k;){
                if(nums[k] + nums[j] > target){
                    k--;
                }else if(nums[k] + nums[j] < target){
                    j++;
                }else{
                    list_tmp.add(nums[j]);
                    list_tmp.add(nums[k]);
                    res.add(new ArrayList(list_tmp));
                    list_tmp.remove(list_tmp.size() - 1);
                    list_tmp.remove(list_tmp.size() - 1);
                    while(j < k && nums[k] == nums[k - 1]){
                        k--;
                    }
                    k --;
                    while(j < k && nums[j] == nums[j + 1]){
                        j++;
                    }
                    j++;
//                    list_tmp = new ArrayList();
                }
            }
        }
        return res;
    }
    public static long mostPoints(int[][] questions) {
        int n = questions.length;
        long[][] dp = new long[n][3];

        dp[n - 1][0] = n - 1;
        dp[n - 1][1] = questions[n - 1][0];
        dp[n - 1][2] = questions[n - 1][1];
        for(int i = n - 2; i >= 0; i--){
//            if(i + questions[i][1]  < dp[i + 1][0]){
//                if( questions[i][0] + dp[i + questions[i][1] + 1][1] > dp[i + 1][1]){
//                    dp[i][0] = i;
//                    dp[i][1] = questions[i][0] + dp[i + questions[i][1] + 1][1];
//                    dp[i][2] = questions[i][1];
//                }else{
//                    dp[i] = dp[i + 1];
//                }
////                dp[i][2] = questions[i][1];
//            }else{
                if(i + questions[i][1] < n - 1){
                    questions[i][0] += dp[i + questions[i][1] + 1][1];
                }
                if(questions[i][0] < dp[i + 1][1]){
                    dp[i] = dp[i + 1];
                }else{
                    dp[i][0] = i;
                    dp[i][1] = questions[i][0];
                    dp[i][2] = questions[i][1];
                }
                // p[i][2] = questions[i][1];
            //}
        }
        long max = 0;
        for(int i = 0; i < questions[0][1] + 1 && i < n; i++){
            max = Math.max(dp[i][1], max);
        }
        return max;
    }
    public static List<List<Integer>> permuteUnique_1(int[] nums) {
        List<List<Integer>> res = new ArrayList();
        boolean []visited = new boolean[nums.length];
        traceBack(nums, res, new LinkedHashSet<Integer>(), visited);
        return res;
    }
    public static void traceBack(int[] nums, List<List<Integer>> res, LinkedHashSet<Integer> tmp, boolean[] visited){
        if(tmp.size() == nums.length){
            res.add(new ArrayList(tmp));
        }
        for(int i = 0; i < nums.length; i++){
            if(!visited[i]){
                tmp.add(nums[i]);
                visited[i] = true;
                traceBack(nums, res, tmp, visited);
                visited[i] = false;
                tmp.remove(tmp.size() - 1);
            }
        }
    }
    static int[] _nums1;
    static int[] _nums2;
    public static List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<List<Integer>> list = new ArrayList();
        List<Integer> tmp;
        boolean isChange = false;
        if(nums1.length > nums2.length){
            _nums1 = nums2;
            _nums2 = nums1;
            isChange = true;
        }else{
            _nums1 = nums1;
            _nums2 = nums2;
        }
        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return _nums1[a[0]] + _nums2[a[1]] - _nums1[b[0]] - _nums2[b[1]];
            }
        });
        int len = Math.min(k, Math.min(_nums1.length, _nums2.length));
        for(int i = 0; i < len; i++){
            pq.add(new int[]{i, 0});
        }
        // if(nums1.length > nums2.length) fun(nums1, nums2, pq, list, k, false);
        // else fun(nums2, nums1, pq, list,  k, true);
        fun(_nums1, _nums2, pq, list,  k, isChange);
        return list;
    }
    public static void fun(int []arr0, int []arr1, PriorityQueue<int[]> pq, List<List<Integer>> list, int k, boolean isChange){
        List<Integer> tmp;
        while(list.size() < k && !pq.isEmpty()){
            int[] t = pq.poll();
            tmp = new ArrayList();
            if(isChange){
                tmp.add(arr1[t[1]]);
                tmp.add(arr0[t[0]]);

            }else{
                tmp.add(arr0[t[0]]);
                tmp.add(arr1[t[1]]);
            }
            list.add(tmp);
            if(t[1] + 1 < arr1.length){
                ++t[1];
                pq.offer(t);
            }
        }
    }
//    public static List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
//        List<List<Integer>> list = new ArrayList();
//        // int j = 0;
//        List<Integer> tmp;
//        boolean isChange = false;
//        int []_nums1;
//        int []_nums2;
//        if(nums1.length > nums2.length){
//            _nums1 = nums2;
//            _nums2 = nums1;
//            isChange = true;
//        }else{
//            _nums1 = nums1;
//            _nums2 = nums2;
//        }
//        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>(){
//            public int compare(int[] a, int[] b){
//                return _nums1[a[0]] + _nums2[a[1]] - _nums1[b[0]] - _nums2[b[1]];
//            }
//        });
//        int len = Math.min(k, Math.min(_nums1.length, _nums2.length));
//        for(int i = 0; i < len; i++){
//            pq.add(new int[]{i,0});
//        }
////        if(isChange) fun(nums1, nums2, pq, list, k, false);
////        else fun(nums2, nums1, pq, list,  k, true);
//        fun(_nums1, _nums2, pq, list, k, isChange);
//        return list;
//    }
//    public static void fun(int []arr0, int []arr1, PriorityQueue<int[]> pq, List<List<Integer>> list, int k, boolean isChange){
//        List<Integer> tmp;
//        while(list.size() < k && !pq.isEmpty()){
//            int[] t = pq.poll();
//            tmp = new ArrayList();
//            if(isChange){
//                int t1 = arr1[t[1]];
//                int t2 = arr0[t[0]];
//                tmp.add(t1);
//                tmp.add(t2);
//            }else{
//                tmp.add(arr0[t[0]]);
//                tmp.add(arr1[t[1]]);
//            }
//            list.add(tmp);
//            if(t[1] + 1 < arr1.length){
//                ++t[1];
//                pq.offer(t);
//            }
//        }
//    }
    public static boolean isAdditiveNumber(String num) {
        if(num.length() < 2) return false;
        else return traceBack(num, 0, new ArrayList<String>());
    }
    public static boolean traceBack(String num, int start, List<String> list){
        // if(start == num.length()) return false;
        // if(list.size() < 2){
        //     return false;;
        // }
        if(start == num.length()){
            return true;
        }
        for(int i = start + 1; i <= num.length(); i++){
            String str = num.substring(start, i);
            if(str.charAt(0) == '0' && str.length() != 1){
                return false;
            }
            if(list.size() < 2 || isAddable(list.get(list.size() - 1), list.get(list.size() - 2), str)){
                list.add(str);
            }else{
                continue;
            }

            if(traceBack(num, i, list) && list.size() > 2){
                return true;
            }
            list.remove(list.size() - 1);
        }
        return false;
    }
    public static boolean isAddable(String num1, String num2, String num3){
        int flag = 0;
        int i = 0;
        int len1 = num1.length();
        int len2 = num2.length();
        int len3 = num3.length();
        if(len3 < len2 || len3 < len1) return false;
        while(i < num1.length() && i < num2.length()){
            int bit1 = num1.charAt(len1 - 1- i) - '0';
            int bit2 = num2.charAt(len2 - 1- i) - '0';
            int bit3 = num3.charAt(len3 - 1- i) - '0';
            if((bit1 + bit2 + flag) % 10 != bit3){
                return false;
            }
            flag = (bit1 + bit2 + flag) / 10;
            i++;
        }
        while(i < num1.length()){
            int bit1 = num1.charAt(len1 - 1- i) - '0';
            int bit3 = num3.charAt(len3 - 1- i) - '0';
            if((bit1 + flag) % 10 != bit3){
                return false;
            }
            flag = (bit1 + flag) / 10;
            i++;
        }
        while(i < num2.length()){
            int bit2 = num2.charAt(len2 - 1- i) - '0';
            int bit3 = num3.charAt(len3 - 1- i) - '0';
            if((bit2 + flag) % 10 != bit3){
                return false;
            }
            flag = (bit2 + flag) / 10;
            i++;
        }
        if(len3 - i == 1){
            if(flag == 1){
                return true;
            }else{
                return false;
            }
        }else if(len3 - i == 0){
            return true;
        }else{
            return false;
        }
    }
    public static List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<Integer> list = new ArrayList();
        list.add(1);
        list.add(2);
        List<Integer> list1 = new ArrayList();
        list1.add(2);
        list1.add(1);
        Set<List<Integer>> set = new HashSet();
        set.add(list);
        set.add(list1);
        System.out.println(set.size());
        // for(int i = 0;i < ){

        // }
        List<List<Integer>> list2 = new ArrayList();
        return list2;
    }
    public static int code_1(String str){
        int code = 0;
        for(int i = 0;i < str.length();i++){
            code |= 1<<(str.charAt(i) - 'a');
        }
        return code;
    }
    public static int fun(int num){
        for(int i = 0;i < 100;i++){
            if( (1<< i) == num){
                return i;
            }
        }
        return -1;
    }
    public static int wordCount_1(String[] startWords, String[] targetWords) {
        Map<Integer, Integer> map = new HashMap();
        int res = 0;
        for(int i = 0; i < targetWords.length;i++){
            int c = code_1(targetWords[i]);
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        for(int i = 0;i < startWords.length;i++){
            int c = code_1(startWords[i]);
            int c1 = code_1("qutn");
            int t = c1 - c;
            System.out.println(fun(t));
            for(int j = 0;j < 26;j++){
                int tmp = 1 << j;
                int search = (tmp | c);
                int cnt = map.getOrDefault(search, 0);
                if(search != c && cnt != 0){
                    res += cnt;
                    map.remove(search);
                }

            }
        }
        return res;
    }
    public static int earliestFullBloom(int[] plantTime, int[] growTime) {
        // int time = 0;
        List<int[]> list = new ArrayList();
        for(int i = 0;i < plantTime.length;i++){
            list.add(new int[]{growTime[i], plantTime[i]});
        }

        Collections.sort(list, new Comparator<int[]>(){
            public int compare(int[]a, int []b){
                return b[0] - a[0];
            }
        });

        int min = 0;
        int tmp = 0;
        for(int i = 0;i < list.size();i++){
            tmp = tmp + list.get(i)[1];
            min = Math.max(tmp + list.get(i)[0], min);
        }
        return min;
    }
    public static int wordCount(String[] startWords, String[] targetWords) {
//        Set<String> res = new HashSet();
        Map<String, int[]> map = new HashMap();
        Map<Integer, List<String>> map2 = new HashMap();
        //
        for(int i = 0;i < targetWords.length;i++){
            int len = targetWords[i].length();
            List<String> list;
            if(map2.containsKey(len)){
                list = map2.get(len);
            }else{
                list = new ArrayList<String>();
            }
            list.add(targetWords[i]);
            map2.put(len,list);
        }

        for(int i = 0;i < targetWords.length;i++){
            int[] frequence = new int[26];
            for(int j = 0;j < targetWords[i].length();j++){
                frequence[targetWords[i].charAt(j) - 'a']++;
            }
            map.put(targetWords[i], frequence);
        }
        int []arr1;
        int res  = 0;
        for(int i = 0;i < startWords.length;i++){
            arr1 = new int[26];
            int len = startWords[i].length();
            for(int j = 0;j < len;j++){
                arr1[startWords[i].charAt(j)-'a']++;
            }

            List<String> list = map2.getOrDefault(len+1,new ArrayList());

            for(int j = 0;j < list.size();j++){
                if(containTo(arr1, map.get(list.get(j)))){
                    res ++ ;
//                    res.add(list.get(j));
                }
            }
        }
        return res;
    }
    public static boolean containTo(int[] arr1, int []arr2){
        for(int i = 0;i < arr1.length;i++){
            if(arr1[i] != 0){
                if(arr1[i] != arr2[i]){
                    return false;
                }
            }
        }
        return true;
    }
    public static int longestPalindrome(String[] words) {
         Set<String> set2 = new HashSet();
        Map<String,Integer> map = new HashMap();
        // int unDubbleChar = 0;
        int res = 0;
        for(int i = 0;i < words.length;i++){

            map.put(words[i], map.getOrDefault(words[i],0)+1);
//
        }
        boolean flag = true;
        // int res = 0;
        for(String str:map.keySet()){
            if(str.charAt(0) == str.charAt(1)){
                int num = map.get(str);
                if(num % 2 == 1){
                    if(flag){
                        flag = false;
                        res += num * 2;
                    }else{
                        res = res + (num-1)*2;
                    }
                }else{
                    res += num * 2;
                }

            }else{
                char[] chs = new char[2];

                chs[0] = str.charAt(1);
                chs[1] = str.charAt(0);

                String str_tmp = new String(chs);
                int num1 = map.getOrDefault(str, 0);
                int num2 = map.getOrDefault(str_tmp, 0);
                int min = Math.min(num1, num2);
                res += min * 2;
            }
        }
        return res;


    }
    public static String simplifyPath(String path) {
        String[] dirs = path.split("/");
        StringBuilder sb = new StringBuilder();

        for(int i = 1;i < dirs.length;i++){
            sb.append('/');
            if(".".equals(dirs[i])){
                sb.deleteCharAt(sb.length()-1);
            }else if("..".equals(dirs[i])){
                reback(sb);
            }else if("".equals(dirs[i])){
                sb.deleteCharAt(sb.length()-1);
            }else{
                sb.append(dirs[i]);
            }
        }
        if("".equals(sb.toString())){
            sb.append("/");
        }
        return sb.toString();
    }
    public static void reback(StringBuilder sb){
        int lastSecondIndex = 0;
        int lastIndex = 0;
        for(int i = 1;i < sb.length();i++){
            if(sb.charAt(i) == '/'){
                lastSecondIndex = lastIndex;
                lastIndex = i;
            }
        }
        sb.delete(lastSecondIndex, lastIndex+1);

    }
    public static void main_1(){
        Scanner sc = new Scanner(System.in);
        int n;
        n = sc.nextInt();
        int k;
        k = sc.nextInt();
        int matched = 0;
        String chs1 ;
        String chs2 ;
        chs1 = sc.next();
        chs2 = sc.next();

        for(int i = 0;i < n;i++){
            if(isMatched(chs1.charAt(i), chs2.charAt(i))){
                matched++;
            }
        }
        String ans = matched >= k ? "YES":"NO";
        System.out.print(ans);

    }
    public static boolean isMatched(char chs1,char chs2){
        if((chs1 == 'A' && chs2 == 'U') || (chs2 == 'A' && chs1 == 'U')){
            return true;
        }else if((chs1 == 'G' && chs2 == 'C') || (chs2 == 'G' && chs1 == 'C')){
            return true;
        }else{
            return false;
        }
    }
    public static boolean isNStraightHand(int[] hand, int groupSize) {
//        if(hand.length % groupSize != 0){
//            return false;
//        }
//        Arrays.sort(hand);
//        ArrayList<Integer> list = new ArrayList();
//        for(int i = hand.length-1;i >= 0 ;i--){
//            list.add(hand[i]);
//        }
//
//        for(int i = list.size() - 1 ;i >= 0;i -= groupSize){
//            if(!valid(list, i, groupSize)){
//                return false;
//            }
//            //remove(list, i);
//        }
//        return true;

        PriorityQueue<Integer> pq = new PriorityQueue();
        Map<Integer, Integer>map = new HashMap();
        for(int num:hand){
            pq.offer(num);
            map.put(num, map.getOrDefault(num, 0)+1);
        }
        while(!pq.isEmpty()){
            int tmp = pq.poll();
            if(map.get(tmp) == 0) continue;
            for(int i = 0;i < groupSize;i++){
                int cnt = map.getOrDefault(tmp+i, 0);
                if(cnt != 0){
                    map.put(tmp+i, cnt-1);
                }else{
                    return false;
                }
            }
        }
        return true;
    }
    public static boolean valid(List<Integer> list, int i,int groupSize){
        boolean flag = true;
        int firstNum = list.get(i);
        for(int j = 0;j < groupSize;j++){
            if(contains(list, firstNum+j) == -1){
                return false;
            }
        }
        return true;
    }
    public static int contains(List<Integer> list,int num){
         for(int i = list.size()-1;i >= 0;i--){
            if(list.get(i) == num){
                list.remove(i);
                return i;
            }
            if(list.get(i) > num + 2) return -1;
        }
        return -1;
    }
    public static int countQuadruplets(int[] nums) {
        //for

        //hash
        int res = 0;
        int []count = new int[601];
        for(int b = nums.length-3;b >= 1;b--){
            for(int d = b+2;d<nums.length;d++){
                count[nums[d] - nums[b+1] + 200]++;
            }
            for(int a = 0;a < b;a++){
                if(count[nums[a] + nums[b] + 200] != 0){
                    res += count[nums[a] + nums[b] + 200];
                }
            }
        }
        return res;
    }
    public static int eatenApples(int[] apples, int[] days) {
        //https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-hfdy0/
        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>(){
            public int compare(int[] a,int []b){
                return a[1]-b[1];
            }
        });
        int i = 0;
        int n = days.length;
        int res = 0;
        while(i < n){
            pq.add(new int[]{apples[i], i+days[i]});
            int []tmp = new int[2];
            while(!pq.isEmpty()){
                tmp = pq.peek();
                if(tmp[1] > i){
                    break;
                }
                pq.poll();
            }
            if(!pq.isEmpty() && tmp[1] > i){//
                res++;
                tmp[0]--;
                //int [] t = pq.poll();
                if(tmp[0] == 0){
                    pq.poll();
                }
            }
            i++;
        }
        while(!pq.isEmpty()){
            int []tmp = new int[2];
            while(!pq.isEmpty()){
                tmp = pq.peek();
                if(tmp[1] > i){
                    break;
                }
                pq.poll();
            }
            if(!pq.isEmpty() && tmp[1] > i){//
                res++;
                tmp[0]--;
                //int[] t = pq.poll();
                if(tmp[0] == 0){
                    pq.poll();
                }
            }
            i++;
        }
        return res;
    }
    static long[] h,p;
    public static String longestDupSubstring(String s) {
        //https://leetcode-cn.com/problems/longest-duplicate-substring/solution/gong-shui-san-xie-zi-fu-chuan-ha-xi-ying-hae9/
        //
        int len = s.length();
        h = new long[len+1];
        p = new long[len+1];
        p[0] = 1;
//        h[0] = s.charAt(0);
        int N = 3;
        for (int i = 0; i < len; i++) {
            p[i + 1] = p[i] * N;
            h[i + 1] = h[i] * N + s.charAt(i);
        }

        int l = 0;
        int r = len-1;
        String ans = "";
        while(l < r){
            int len_tmp = (r-l+1)/2;
            int mid = l + (r-l+1)/2;
            if(mid <= 1) break;
            String tmp = check(s, mid);
            if(tmp == ""){
                r = mid-1;
            }else{
                ans = ans.length()<tmp.length()?tmp:ans;
                //return ans;
                l = mid+1;
            }
        }
        return ans;
    }
    public static String check(String s,int len){
        Set<Long>set = new HashSet();
        for(int i = 0;i+len-1<s.length();i++){
            int j = i+len-1;
            long tmp = h[j] - h[i]*p[len-1];
            if(set.contains(tmp)) return s.substring(i,j+1);
            set.add(tmp);
        }
        return "";
    }
    static int []_quiet;
    public static int[] loudAndRich(int[][] richer, int[] quiet) {
        _quiet = quiet;
        Map<Integer,List<int[]>> map = new HashMap();
        for(int i = 0;i<richer.length;i++){
            if(map.containsKey(richer[i][1])){
                List<int[]> list = map.get(richer[i][1]);
                list.add(new int[]{richer[i][0],quiet[richer[i][0]]});
            }else{
                List<int[]>tmp = new ArrayList();
                tmp.add(new int[]{richer[i][0],quiet[richer[i][0]]});
                map.put(richer[i][1],tmp);
            }
        }
        int []res = new int[quiet.length];
        for(int i = 0;i<res.length;i++){
            //res[i] = dfs(map,i);
        }
        return res;
    }
    public static void dfs(int x,Map<Integer,List<int[]>> map,int []quiet,int []res){
        if(map.containsKey(x)){
            List<int []> list = map.get(x);
            //res[x] = x;

            //int res = list.get(0)[0];
            for(int j = 0;j<list.size();j++){
                int tmp = list.get(j)[0];
                dfs(tmp,map, quiet,res);
                res[x] = quiet[x] > quiet[res[x]]?res[x]:x;
            }
//            int person = dfs(map, list.get(0)[0]);
//            return _quiet[person]>_quiet[res]?res:person;
        }else{
            res[x] = x;
        }
    }
    public static int scheduleCourse(int[][] courses) {
        Arrays.sort(courses,new Comparator<int[]>(){
            public int compare(int[]a,int[]b){
                return a[1] - b[1];
            }
        });
        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer o1,Integer o2){
                return o2-o1;
            }
        });
        int duration = 0;
        for(int i = 0;i<courses.length;i++){
            pq.offer(courses[i][0]);
            duration += courses[i][0];
            if(courses[i][1] < duration){
                int tmp = pq.poll();
                duration -= tmp;
            }
        }
        return pq.size();

    }
    public static void TopVotedCandidate(int[] _person, int[] _times) {
        // _person = persons;
        // _times = times;
        Map<Integer,Integer> map = new HashMap();
        int i;
        int val = 0;
        for(i = 0;i<_times.length;i++){
            map.put(_person[i],map.getOrDefault(_person[i],0)+1);
            if(map.get(_person[i])>=val ){
                list.add(new int[]{_times[i],_person[i]});
            }
        }
    }

    static List<int[]> list = new ArrayList();
    public static int q(int t) {
        int l = 0,r = list.size()-1;
        while(l<=r){
            int mid = (r-l)/2+l;
            if(list.get(mid)[0]==t){
                return list.get(mid)[1];
            }else if(list.get(mid)[0]<t){
                l = mid+1;
            }else{
                r = mid-1;
            }
        }
        return list.get(l)[1];
    }
    static  ArrayList<int[]> superPow_list1 = new ArrayList<>();
    static  ArrayList<int[]> superPow_list2 = new ArrayList<>();
    public static int fun2(int a,int exp){
        if(exp == 0){
            return 1;
        }
        if(exp % 2 == 0){
            int tmp = fun2(a,exp/2)%1337;
            return (tmp * tmp)%1337;
        }else{
            int tmp = fun2(a,exp/2)%1337;
            return ((a%1337) * (tmp * tmp))%1337;
        }
    }
    public static  int superPow(int a,Deque<Integer>deq){
        if(deq.isEmpty()){
            return 1;
        }
        int tmp = deq.removeLast();
        int part1 = fun2(a, tmp);
        int part2 = fun2(superPow(a,deq),10);
        superPow_list1.add(new int[]{part1, part2});
        return (part1 * part2) % 1337;
    }
    public static  int superPow(int a, int[] b) {
        Deque<Integer> que = new ArrayDeque();
        for(int n:b){
            que.addLast(n);
        }
        return superPow(a%1337,que);
    }

     static int base = 1337;
     public static int _superPow(int a, int[] b) {
         Deque<Integer> queue = new ArrayDeque<>();

         for(int num : b)
             queue.addLast(num);
         return _superPow(a, queue);
     }

     private static int _superPow(int a, Deque<Integer> queue){
         if(queue.isEmpty())
             return 1;

         int lastBit = queue.removeLast();

         int part1 = _myPow(a, lastBit);
         int part2 = _myPow(superPow(a, queue), 10);
         superPow_list2.add(new int[]{part1,part2});
         return (part1 * part2) % base;
     }

         // (a * b) % k = [(a % k) * (b % k)] % k
     /*
         assume    mod k 
     */
     private static int _myPow(int a, int b){
         if(b == 0)
             return 1;
         if(b % 2 == 0)
             return _myPow( ((a % base) * (a % base)) % base, b / 2);
         else
             return (  (a % base) * _myPow(a, b - 1)  ) % base;
     }
    public static boolean canConstruct(String ransomNote, String magazine) {
        char[] num = new char[26];
        System.out.println((int)(--num[0]));
        for(int i = 0;i < magazine.length();i++){
            int tmp = magazine.charAt(i)-'a';
            num[tmp]++;
        }
        for(int i = 0;i < ransomNote.length();i++){
            int tmp = ransomNote.charAt(i)-'a';
            int t = --num[tmp];
            if(t < 0){
                return false;
            }
        }
        return true;
    }
    public static int sum(int[] nums){
        int res = 0;
        for(int j = 0;j < nums.length;j++){
            if(nums[j] > 0){
                res += nums[j];
            }
        }
        return res;
    }
    public static int largestSumAfterKNegations(int[] nums, int k) {
        //
        Arrays.sort(nums);
        int n = nums.length;
        if(nums[0] == 0){
            return sum(nums);
        }else if(nums[0] > 0){
            if(k % 2 == 0){
                return sum(nums);
            }else{
                nums[0] *= -1;
                return sum(nums);
            }
        }else{
            boolean flag = false;
            for(int i = 0;i<n;i++){
                if(nums[i] == 0){
                    flag = true;
                }
            }
            int min = 100000;
            for(int i = 0;i<n && k>0 && nums[i]<0;i++){
                nums[i] *= -1;
                min = Math.min(min,nums[i]);
            }
            if(k>0){
                if(flag){
                    return sum(nums);
                }else{
                    if(k%2==0){
                        return sum(nums);
                    }else{
                        return sum(nums)-2*min;
                    }
                }
            }else{
                return sum(nums);
            }
        }

    }
    public static String[] findRelativeRanks(int[] score) {
        int[][]score_pos = new int[score.length][2];
        for(int i = 0;i<score.length;i++){
            score_pos[i][0] = score[i];
            score_pos[i][1] = i;
        }
        Arrays.sort(score_pos,new Comparator<int[]>(){
            public int compare(int[] a,int []b){
                return b[0] - a[0];
            }
        });
        String[] res = new String[score.length];
        for(int i = 0;i<score.length;i++){
            res[score_pos[i][1]] = i+1+"";
        }
        res[score_pos[0][1]] = "Gold Medal";
        res[score_pos[1][1]] = "Silver Medal";
        res[score_pos[2][1]] = "Bronze Medal";
        return res;
    }
    public static List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>();
        int n = s.length(), m = p.length();
        int[] cnt = new int[26];
        for (int i = 0; i < m; i++) cnt[p.charAt(i) - 'a']++;
        int a = 0;
        for (int i = 0; i < 26; i++) if (cnt[i] != 0) a++;
        for (int l = 0, r = 0, b = 0; r < n; r++) {
            //  0 p 
            if (--cnt[s.charAt(r) - 'a'] == 0) b++;
            //  1 0 p 
            if (r - l + 1 > m && ++cnt[s.charAt(l++) - 'a'] == 1) b--;
            if (b == a) ans.add(l);
        }
        return ans;
    }

    static int res_numberOf2sInRange = 0;
    static int num1 = 10;
    static int num2 = 100;
    static int num3 = 1000;
    static int num4 = 10000;
    static int num5 = 100000;
    static int num6 = 1000000;
    static int num7 = 10000000;
    static int num8 = 100000000;
    static int num9 = 1000000000;
    static int []arr = new int[]{1,20,300,4000,50000,600000,7000000,80000000};
    public static int fun(int n,int num,int i){
        if(n<num*2){
            res_numberOf2sInRange += arr[i];
            n -= num;
        }else if(n > num*3){
            int tmp1 = n/num;
            res_numberOf2sInRange += arr[i] * tmp1 + num;
            n -= num*tmp1;
        }else{
            res_numberOf2sInRange += arr[i]*2;
            res_numberOf2sInRange += n-num*2+1;
            n -= num*2;
        }
        return n;
    }
    public static int numberOf2sInRange(int n) {
        // 0-10 2 1
        // 11 -19 1
        // 20-29 10+1
        // 30-39 1
        // 11-99 *2 9
        //         2* 9
        // 0-99  1*10 + 10 = 20
        // 100-199 20
        // 200-299 100 + 20
        // 300 - 999 7 * 19

        // 0-999 20* 10 + 100 = 300
        //{1,20,300,4000,50000,600000,7000000,80000000}

        while(n>0){
            if(n > num9){
                return -1;
            }else if(n > num8){
                n = fun(n,num8,7);
            }else if(n > num7){
                n = fun(n,num7,6);
            }else if(n > num6){
                n = fun(n,num6,5);
            }else if(n > num5){
                n = fun(n,num5,4);
            }else if(n > num4){
                n = fun(n,num4,3);
            }else if(n > num3){
                n = fun(n,num3,2);
            }else if(n > num2){
                n = fun(n,num2,1);
            }else if(n > num1){
                n = fun(n,num1,0);
            }else{
                if(n>=2){
                    res_numberOf2sInRange++;
                }
                break;
            }
        }
        return res_numberOf2sInRange;
    }
    public static int[] flip(int _m,int _n) {
        Set<Integer> set = new HashSet<>();
        Random r = new Random();
        while(true){
            int tmp = r.nextInt(_m*_n);
            if(!set.contains(tmp)){
                int x = tmp / _n;
                int y = tmp % _n;
                set.add(tmp);
                return new int[]{x,y};
            }
        }
    }
    static char[] chs;
    public static int contains(String str){
        int min = 100000;
        for(int i = 0;i<str.length();i++){
            min = Math.min(chs[str.charAt(i)-'a'],min);
        }
        for(int i = 0;i<str.length();i++){
            int tmp = str.charAt(i)-'a';
            chs[tmp] -= min;
        }
        return min;
    }
    public static String originalDigits(String s) {
        Map<String,Integer> map =new HashMap();
        map.put("zero",0);
        map.put("six",6);
        map.put("two",2);
        map.put("three",3);
        map.put("four",4);
        map.put("five",5);
        map.put("eight",8);
        map.put("nine",9);
        map.put("one",1);
        map.put("seven",7);
        String[] digital = {"zero", "six", "two","four","five","eight","three","nine","one","seven"};
        chs = new char[26];
        for(int i = 0;i<s.length();i++){
            int tmp = s.charAt(i)-'a';
            chs[tmp]++;
        }
        StringBuilder sb = new StringBuilder();
        for(int i = 0;i<digital.length;i++){
            int tmp = contains(digital[i]);
            for(int j = 0;j<tmp;j++){
                sb.append(map.get(digital[i]));
            }
        }
        String str = sb.toString();
        char []tmp = str.toCharArray();
        Arrays.sort(tmp);
        return new String(tmp);
    }
    public static String getHint(String secret, String guess) {
        int bulls = 0;
        int cows = 0;
        Map<Character,Integer> map = new HashMap();
        for(int i = 0;i<secret.length();i++){
            if(secret.charAt(i) != guess.charAt(i)){
                map.put(secret.charAt(i),map.getOrDefault(secret.charAt(i),0)+1);
            }
        }
        for(int i = 0;i<guess.length();i++){
            if(secret.charAt(i) == guess.charAt(i)){
                bulls++;
            }else{
                if(map.getOrDefault(guess.charAt(i),0)>0){
                    cows++;
                    map.put(guess.charAt(i),map.get(guess.charAt(i))-1);
                }
            }
        }

        char [] res = new char[4];
        res[0] = (char)(bulls+'0');
        res[1] = 'A';
        res[2] = (char)(cows+'0');
        res[3] = 'B';
        return new String(res);
    }
    public static int fun1(int n){
        int res = 0;
        int tmp = 0;
        for(int i = n;i!=0;i = i+tmp){
            tmp = i|-i;
            res++;
        }
        return res;
    }
    public static int fun2(int n){
        int res = 0;
        int tmp = 0;
        for(int i = n;i!=0;i = i-tmp){
            tmp = i&-i;
            res++;
        }
        return res;
    }
    public static int fun3(int n){
        int res = 0;
        for(int i = 0;i<32;i++){
            if((n&1) == 1){
                res++;
            }
            n = n>>>1;
        }
        return res;
    }
//    static char[] chs = new char[128];
    public static void function(String s,int j){
        for(int i = 0;i<s.length();i++){
            chs[s.charAt(i)] = (char)j;
//            System.out.println(s.charAt(i)-0);
//            System.out.println(chs[s.charAt(i)]==0);
            chs[s.charAt(i)-32] = (char)j;
        }
    }
    public static String[] findWords(String[] words) {
        List<String> res = new ArrayList();
        //char []chs = new char[128];
        String s1 = "qwertyuiop";
        String s2 = "asdfghjkl";
        String s3 = "zxcvbnm";
        function(s1,1);
        function(s2,2);
        function(s3,3);
        for(int i = 0;i<words.length;i++){
            int j;
            for(j = 0;j<words[i].length()-1;j++){
                char tmp1 = words[i].charAt(j);
                char tmp2 = words[i].charAt(j+1);
                if(chs[tmp1] != chs[tmp2]){
                    break;
                }
            }
            if(j == words[i].length()-1){
                res.add(words[i]);
            }
        }
        return res.toArray(new String[res.size()]);
    }
    static List<int[]> _pos;
    public static int binaryS(int i){
        int start = 0;
        int end = _pos.size()-1;
        int mid = 0;
        while(start<=end){
            mid = (end-start)/2+start;
            if(_pos.get(mid)[0] == i) return mid;
            else if(_pos.get(mid)[0] < i){
                start = mid+1;
            }else{
                end = mid-1;
            }
        }
        if(start == 0)
            return 0;
        return start-1;
    }
    public static int[] platesBetweenCandles(String s, int[][] queries) {
        List<int[]> pos = new ArrayList();
        int flag = -1;
        for(int i = 0;i<s.length();i++){
            if(s.charAt(i) == '|'){
                int []tmp = new int[2];
                tmp[0] = i;
                if(flag != -1){
                    tmp[1] = i-flag-1+pos.get(pos.size()-1)[1];

                }else{
                    tmp[1] = 0;

                }
                pos.add(tmp);
                flag = i;
            }
        }
        _pos = pos;
        int result[] = new int[queries.length];
        for(int i = 0;i<queries.length;i++){

            int t1 = binaryS(queries[i][0]);
            if(s.charAt(queries[i][0])!='|'){
                //t1++;
            }
            int s1 = _pos.get(t1)[1];
            int t2 = binaryS(queries[i][1]);
            int s2 = _pos.get(t2)[1];
            result[i] = s2-s1;
        }
        return result;
    }
//    public static int[] platesBetweenCandles(String s, int[][] queries) {
//        int result[] = new int[queries.length];
//        for(int i = 0;i<queries.length;i++){
//            int []tmp = queries[i];
//            int flag = -1;
//            int res = 0;
//            for(int j = tmp[0];j<=tmp[1];j++){
//                if(s.charAt(j)=='|'){
//                    if(flag != -1){
//                        res += j-flag-1;
//                        flag = j;
//                    }else{
//                        flag = j;
//                    }
//                }
//            }
//            result[i] = res;
//        }
//        return result;
//    }
    public static String my_toBinary(int i){
//        char[] chs = new char[32];
        StringBuilder chs = new StringBuilder();
        int j = 0;
        for(;j<32;j++){
            if(j%4==0){
                chs.insert(0,' ');
            }
            chs.insert(0,(char) (((i>>j) & 1)+'0'));
        }
        return new String(chs);
    }
    public static int[] singleNumber(int[] nums) {
        int sum = 0;
        for(int i = 0;i<nums.length;i++){
            sum ^= nums[i];
        }
        int k = -1;
        for(int i = 31;i>=1 && k==-1;i--){
            if(((sum>>i)&1)==1){
                k = i;
            }
        }
        System.out.println(my_toBinary(sum));
        System.out.println(Integer.toBinaryString(sum));
        int []res = new int[2];
        for(int i:nums){
            System.out.println(Integer.toBinaryString(i >>> k));
            if(((i>>k)&1) == 1){
                res[1] ^= i;
            }else{
                res[0] ^= i;
            }
        }
        return res;
    }
    public static String intToString(int n){
        char [] chs = new char[32];
        int i = 0;
        while(n > 0){
            int tmp = n%10;
            chs[i++] = (char)(tmp+'0');
            n = n/10;
        }
        Arrays.sort(chs);
        return new String(chs);
    }
    public static boolean reorderedPowerOf2(int n) {
        Set<String> set = new HashSet();
        for(int i = 0;i<32;i++){
            String tmp = intToString(1<<i);
            set.add(tmp);
        }
        String str = intToString(n);
        return set.contains(str);
    }
    public static int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer,Integer> map = new HashMap();
        int []res = new int[nums1.length];
        for(int i = 0;i<nums2.length-1;i++){
            map.put(nums2[i],nums2[i+1]);
        }
        map.put(nums2[nums2.length-1],-1);
        for(int j = 0;j<nums1.length;j++){
            int num = nums1[j];
            while(true){
                int tmp = map.get(num);
                if(tmp == -1 || tmp > nums1[j]){
                    res[j] = tmp;
                    break;
                }else{
                    num = tmp;
                }
            }
        }
        return res;
    }
    public static int countValidWords(String sentence) {
        int res = 0;
        String []strs = sentence.split(" ");
        for(int i = 0;i<strs.length;i++){
            if(strs[i].length()>0){
                int j ;
                int nums = 0;
                for(j = 0;j<strs[i].length();j++){
                    if(strs[i].charAt(j)>='0'&&strs[i].charAt(j)<='9'){
                        break;
                    }else if(strs[i].charAt(j)=='-'){
                        if(nums == 1){
                            break;
                        }else if(j>0 && j+1<strs[i].length() && strs[i].charAt(j-1)>='a' && strs[i].charAt(j-1) <= 'z' && strs[i].charAt(j+1) >= 'a' && strs[i].charAt(j+1) <= 'z'){//
                            nums++;
                            continue;
                        }else{
                            break;
                        }
                    }else if(strs[i].charAt(j) == ',' || strs[i].charAt(j) == '.' || strs[i].charAt(j) == '!'){
                        if(j==strs[i].length()-1){
                            continue;
                        }else{
                            break;
                        }
                    }
                }
                if(j == strs[i].length()){
                    res++;
                }
            }
        }
        return res;
    }
    public static int kthSmallest(TreeNode root, int k){
        Deque<TreeNode> q = new ArrayDeque<>();
        while(root != null || !q.isEmpty()){
            while(root !=null){
                q.add(root);
                root = root.left;
            }
            root = q.pop();
            if(--k == 0) return root.value;
            root = root.right;
        }
        return -1;
    }
    public static int minMoves(int[] nums) {
        int sum = 0;
        int max = nums[0];
        for(int i = 0;i<nums.length;i++){
            sum += nums[i];
            if(nums[i] > max){
                max = nums[i];
            }
        }
        int k = max;
        int n = nums.length;
        if(n == 1 && sum == 0)
            return 0;
        while(true){
            if((n * k-sum)%(n-1)==0){
                return (n * k-sum)/(n-1);
            }
            k++;
        }
        //return -1;
    }
    public static int findComplement(int num) {
        int res = 0;
        int i = 0;
        while(num > 0){
            int tmp = num>>1;
            tmp = (tmp<<1)+1;
            tmp  = tmp^num;
            res = res + (int)(tmp*Math.pow(2,i));
            i++;
            num = num>>1;
        }
        return res;
    }
    static int res_int = 0;
    public static int huo(List<Integer> list){
        int s = 0;
        for(int i = 0;i<list.size();i++){
            s |= list.get(i);
        }
        return s;
    }
    public static List<List<Integer>> my_Copy(List<List<Integer>> list){
        List<List<Integer>> res = new ArrayList<>();
        for(int i = 0;i<list.size();i++){
            List<Integer> l1 = new ArrayList<>();
            for(int j = 0;j<list.get(i).size();j++){
                l1.add(list.get(i).get(j));
            }
            res.add(l1);
        }
        return res;
    }

    public static int countMaxOrSubsets(int[] nums) {
        List<Integer> l1 = new ArrayList();
        for(int i = 0;i<nums.length;i++){
            l1.add(nums[i]);
        }
        int target = huo(l1);
        List<Integer> l2 = new ArrayList();
        List<List<Integer>> l3 = new ArrayList();
        l3.add(l2);
        for(int i = 0;i<nums.length;i++){
            List<List<Integer>> l4 = my_Copy(l3);
            for(int j = 0;j<l4.size();j++){
                l4.get(j).add(nums[i]);
            }
            l3.addAll(l4);
        }
        for(int i = 0;i<l3.size();i++){
            if(huo(l3.get(i)) == target){
                res_int++;
            }
        }
        return res_int;

    }
    public static boolean areNumbersAscending(String s) {
        String[] split = s.split(" ");
        int pre = -1;
        for(int i = 0;i<split.length;i++){
            if(split[i].charAt(0)>'0' && split[i].charAt(0)<='9'){
                int tmp = Integer.valueOf(split[i]);
                if(tmp <= pre){
                    return false;
                }
                pre = tmp;
            }
        }
        return true;
    }
    public static int longestCommonSubsequence(String text1, String text2) {
        int[][] f = new int[text1.length()+1][text2.length()+1];
        f[0][0] = 1;
        for(int i = 1;i<text1.length()+1;i++){
            f[i][0] = 1;
        }
        for(int j = 1;j<text2.length()+1;j++){
            f[0][j] = 1;
        }
        for(int i = 1;i<text1.length()+1;i++){
            for(int j = 1;j<text2.length()+1;j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    f[i][j] = f[i-1][j-1]+1;
                }else{
                    f[i][j] = Math.max(f[i-1][j],f[i][j-1]);
                }
            }
        }
        return f[text1.length()][text2.length()]-1;
    }
    public static int divide(int dividend, int divisor) {
        int res = 0;
        int flag = -1;
        if((dividend <0 && divisor <0) ||(dividend >0 && divisor >0)){
            flag = 1;
        }
        long a = Math.abs(dividend);
        int b = Math.abs(divisor);
        if(dividend == Integer.MIN_VALUE){
            if(divisor == -1){
                return Integer.MAX_VALUE;
            }else if(divisor == 1){
                return Integer.MIN_VALUE;
            }
            a = 2147483648l;
        }
        while(a>=b){
            int s = b;
            int cnt = 1;
            while(s<(a>>1)){
                cnt += cnt;
                s += s;
            }
            res += cnt;
            a -= s;
        }
        return res*flag;
    }
    public static List<String> findRepeatedDnaSequences(String s) {
//        Map<String,Integer> map = new HashMap<>();
//        //StringBuilder sb = new StringBuilder();
//        List<String> res = new ArrayList();
//        for (int i = 0; i <= s.length()-10; i++) {
//            String str = s.substring(i,i+10);
//            if(map.containsKey(str)){
//                if(map.get(str) == 1){
//                    res.add(str);
//                }else{
//                    map.put(str,map.get(str)+1);
//                }
//            }else{
//                map.put(str,1);
//            }
//        }
//        return res;
        StringBuilder sb = new StringBuilder();
        Set<StringBuilder> set = new HashSet<>();
        List<String> res = new ArrayList<>();
        for(int i = 0;i<s.length();i++){
            sb.append(s.charAt(i));
            if(sb.length()==10){
                if(set.contains(sb)){
                    res.add(sb.toString());
                }else{
                    set.add(sb);
                }
                sb.deleteCharAt(0);
            }
        }
        return res;
    }
        public static int thirdMax(int[] nums) {
//        long a = Integer.MIN_VALUE;
//        long b = Integer.MIN_VALUE;
//        long c = Integer.MIN_VALUE;
//        Set<Integer>set = new HashSet();
//        for(int i = 0;i<nums.length;i++){
//            if(set.contains(nums[i])){
//                continue;
//            }else{
//                set.add(nums[i]);
//            }
//            if(nums[i]>c){
//                a = b;
//                b = c;
//                c = nums[i];
//            }else if(nums[i]>b){
//                a = b;
//                b = nums[i];
//            }else if(nums[i]>a){
//                a = nums[i];
//            }
//        }
//        return (int) (a==(Integer.MIN_VALUE-1)?c:a);
        long a = Long.MIN_VALUE;
        long b = Long.MIN_VALUE;
        long c = Long.MIN_VALUE;
        Set<Integer>set = new HashSet();
        for(int i = 0;i<nums.length;i++){
            if(set.contains(nums[i])){
                continue;
            }else{
                set.add(nums[i]);
            }
            if(nums[i]>c){
                a = b;
                b = c;
                c = nums[i];
            }else if(nums[i]>b){
                a = b;
                b = nums[i];
            }else if(nums[i]>a){
                a = nums[i];
            }
        }

        return (int)(a==(Long.MIN_VALUE)?c:a);
    }
    public static String fractionToDecimal(int numerator, int denominator) {
        long a = numerator;
        long b = denominator;
        if(a%b == 0){//
            return String.valueOf(a/b);
        }
        StringBuilder sb = new StringBuilder();

        if(a*b<0){
            sb.append("-");
        }
        a = Math.abs(a);
        b = Math.abs(b);
        sb.append(a/b+".");
        Map<Long,Integer>map = new HashMap();
        a = a%b;
        int u = sb.length();
        while(a!=0){
            if(map.containsKey(a)){
                int pos = map.get(a);
                return String.format("%s(%s)",sb.substring(0,pos),sb.substring(pos));
            }
            map.put(a,u);
            a = a*10;
            for(int i = 9;i>=0;i--){
                if(a>b*i){
                    sb.append(i);
                    a = a-b*i;
                    u++;
                    break;
                }else if(a==b*i){
                    sb.append(i);
                    return sb.toString();
                }
            }
        }
        return null;
    }

    public static int numDecodings(String s){
        int MOD = 1000000007;
        //int res = 0;
        int a = 0;
        int b = 1;
        int c = 0;
        for(int i = 0;i<s.length();i++){
            c = (b*checkOneDigit(s.charAt(i)))%MOD;
            if(i>0){
                c += (a*checkTwoDigit(s.charAt(i-1),s.charAt(i)))%MOD;
            }
            a = b;
            b = c;
        }
        return c;
    }
    public static int checkOneDigit(char c){
        if(c == '*'){
            return 9;
        }else if(c == '0'){
            return 0;
        }else{
            return 1;
        }
    }
    public static int checkTwoDigit(char c1,char c2){
        if(c1 == '*'){
            if(c2 == '*'){
                return 15;
            }else if(c2 < '7'){
                return 2;
            }else{
                return 1;
            }
        }else if(c1 == '0'){
            return 0;
        }else{
            if(c2 == '*'){
                if(c1 == '1'){
                    return 9;
                }else if(c1 == '2'){
                    return 6;
                }else{
                    return 0;
                }
            }else{
                int tmp = (c1-'0')*10 + c2-'0';
                if(tmp<27){
                    return 1;
                }else{
                    return 0;
                }
            }
        }
    }
    public static String toHex(int num) {
        if(num==0)
            return "0";
        StringBuilder sb = new StringBuilder();
        while(num != 0){
            int tmp = num&15;
            char c;
            if(tmp>=10){
                c = (char)('a'+tmp-10);
                sb.insert(0,c);
            }else{
                c = (char)('0'+tmp);
                sb.insert(0,c);
            }
            num = num>>>4;
        }
        return sb.toString();
    }
    public static void func(char[] content){
        double ACount = 0;
        double BCount = 0;
        double CCount = 0;
        double DCount = 0;
        for(int i = 0;i<content.length;i++){
            if(content[i] == 'A'){
                ACount++;
            }else if(content[i] == 'B'){
                BCount++;
            }else if(content[i] == 'C'){
                CCount++;
            }else{
                DCount++;
            }
        }
        double PA = ACount/(double) (content.length);
        double PB = BCount/(double) (content.length);
        double PC = CCount/(double) (content.length);
        double PD = DCount/(double) (content.length);
        double res = 0.0;
        if(PA != 0.0){
            res += PA * Math.log(PA)/Math.log(2);
        }
        if(PB != 0.0){
            res += PB * Math.log(PB)/Math.log(2);
        }
        if(PC != 0.0){
            res += PC * Math.log(PC)/Math.log(2);
        }
        if(PD != 0.0){
            res += PD * Math.log(PD)/Math.log(2);
        }
        res = -1 * res;
        System.out.println(String.format("%.2f", res));
    }
    public static Node func(Node head){
        Node pre = null;
        Node tail = null;
        while(head != null){
            if(tail != null){
                head.prev = tail;
                tail = null;
            }
            if(head.child != null){
                tail = func(head.child);
                pre = tail;
                tail.next = head.next;
                head.next = head.child;
                head.child = null;
                head = tail.next;
            }else{
                pre = head;
                head = head.next;
            }
        }
        return pre;
    }
    public static Node flatten(Node head) {
        Node res = head;
        if(head == null){
            return null;
        }else{
            Node tail = func(head);
        }
        return res;
    }
    public static String countAndSay(int n) {
        String[] res = new String[n];
        res[0] = "1";
        for(int i = 1;i<n;i++){
            int count = 1;
            StringBuilder sb = new StringBuilder();
            int cur = 0;//= res[i-1].charAt(1)
            int pre = 0;
            for(int j = 1;j<res[i-1].length();j++){
                // int pre = res[i-1].charAt(j-1);
                // cur = res[i-1].charAt(j);
                cur = j;
                if(res[i-1].charAt(pre)!=res[i-1].charAt(cur)){
                    sb.append(count+""+res[i-1].charAt(pre));
                    pre = j;
                    count = 1;
                }else{
                    count++;
                }
            }
            sb.append(count+""+res[i-1].charAt(cur));
            res[i] = sb.toString();
        }
        return res[n-1];
    }
    private static class TrieNode{
        String s;
        TrieNode[] arr = new TrieNode[26];
    }
    public static void insert(String s,TrieNode p){
        for(int i = 0;i<s.length();i++){
            int tmpNum = s.charAt(i)-'a';
            if(p.arr[tmpNum]==null){
                p.arr[tmpNum] = new TrieNode();
            }
            p = p.arr[tmpNum];
        }
        p.s = s;
    }
    static TrieNode root = new TrieNode();
    //TrieNode p = root;
    static boolean [][]visited = new boolean[12][12];
    static char[][]_board;
    static Set<String> res = new HashSet();
    static int m;
    static int n;
    static int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};
    public static List<String> findWords(char[][] board, String[] words) {
        _board = board;
        m = board.length;
        n = board[0].length;
        for(String w:words){
            insert(w,root);
        }
        for(int i = 0;i<board.length;i++){
            for(int j = 0;j<board[0].length;j++){
                int tmpNum = board[i][j]-'a';
                if(root.arr[tmpNum]!=null){
                    visited[i][j] = true;
                    dfs(i,j,root.arr[tmpNum]);
                    visited[i][j] = false;
                }

            }
        }
        return new ArrayList(res);
    }
    public static void dfs(int i,int j,TrieNode r){

        if(r.s!=null){
            res.add(r.s);
        }
        for(int[]d:dirs){
            int dx = i+d[0];
            int dy = j+d[1];
            if(dx<0||dx>=m||dy<0||dy>=n||visited[dx][dy]==true){
                continue;
            }
            int tmpNum = _board[dx][dy]-'a';
            if(r.arr[tmpNum]!=null){
                visited[dx][dy] = true;
                dfs(dx,dy,r.arr[tmpNum]);
                visited[dx][dy] = false;
            }

        }

    }
//    private static class TrieNode{
//        String s;
//        TrieNode[] arr = new TrieNode[26];
//    }
//    public static void insert(String s,TrieNode p){
//        for(int i = 0;i<s.length();i++){
//            int tmpNum = s.charAt(i)-'a';
//            if(p.arr[tmpNum]==null){
//                p.arr[tmpNum] = new TrieNode();
//            }
//            p = p.arr[tmpNum];
//        }
//        p.s = s;
//    }
//    static TrieNode root = new TrieNode();
//    //static TrieNode p = root;
//    static boolean [][]visited = new boolean[12][12];
//    static char[][]_board;
//    static Set<String> res = new HashSet();
//    static int m;
//    static int n;
//    public static List<String> findWords(char[][] board, String[] words) {
//        _board = board;
//        m = board.length;
//        n = board[0].length;
//        for(String w:words){
//            insert(w,root);
//        }
//        for(int i = 0;i<board.length;i++){
//            for(int j = 0;j<board[0].length;j++){
//                visited[i][j] = true;
//                dfs(i,j,root);
//                visited[i][j] = false;
//            }
//        }
//        return new ArrayList(res);
//    }
//    public static void dfs(int i,int j,TrieNode r){
//        int tmpNum = _board[i][j]-'a';
//        if(r.s!=null){
//            res.add(r.s);
//        }
//        if(r.arr[tmpNum]!=null){
//            if(i-1>=0){//up
//                visited[i-1][j] = true;
//                dfs(i-1,j,r.arr[tmpNum]);
//                visited[i-1][j] = false;
//            }
//            if(i+1<n){//down
//                visited[i+1][j] = true;
//                dfs(i+1,j,r.arr[tmpNum]);
//                visited[i+1][j] = false;
//            }
//            if(j-1>=0){//left
//                visited[i][j-1] = true;
//                dfs(i,j-1,r.arr[tmpNum]);
//                visited[i][j-1] = false;
//            }
//            if(j+1<m){//right
//                visited[i][j+1] = true;
//                dfs(i,j+1,r.arr[tmpNum]);
//                visited[i][j+1] = false;
//            }
//        }
//    }

    public static int minSteps(int n) {
        int res = 0;
        int i;
        if(n==1){
            return 0;
        }
        for(i = 2;i<n/2;){
            if(n%i==0){
                res += i;
                n = n/i;
                i = 2;
            }else {
                i++;
            }
        }
        if(i>=n/2){
            return n+res;
        }
        return res;
    }
    public static boolean rowIsValid(char[][] board,int row){
        Set<Character> set = new HashSet();
        for(int j = 0;j<board[row].length;j++){
            if(board[row][j]=='.')
                continue;
            if(set.contains(board[row][j])){
                return false;
            }else{
                set.add(board[row][j]);
            }
        }
        return true;
    }
    public static boolean columnIsValid(char[][] board,int column){
        Set<Character>set = new HashSet();
        for(int i = 0;i<board.length;i++){
            if(board[i][column]=='.')
                continue;
            if(set.contains(board[i][column])){
                return false;
            }else{
                set.add(board[i][column]);
            }
        }
        return true;
    }
    public static boolean matrixIsValid(char[][] board,int index){
        int row = index/3;
        int column = index%3;
        Set<Character>set = new HashSet();
        int start = column*3;
        for(int i = row*3;i<(row+1)*3;i++ ){
            for(int j = start;j<start+3;j++){
                if(board[i][j]=='.')
                    continue;
                if(set.contains(board[i][j])){
                    return false;
                }else{
                    set.add(board[i][j]);
                }
            }
        }
        return true;
    }
    public static boolean isValidSudoku(char[][] board) {
        boolean flag = true;
        for(int i = 0;i<board.length;i++){
            flag &= rowIsValid(board,i);
        }
        for(int j = 0;j<board[0].length;j++){
            flag &= columnIsValid(board,j);
        }
        for(int k = 0;k<9;k++){
            flag &= matrixIsValid(board,k);
        }
        return flag;
    }
    public static String findLongestWord(String s, List<String> dictionary) {
        Collections.sort(dictionary,new Comparator(){
            public int compare(Object o1,Object o2){
                if(((String)o1).length()==((String)o2).length()){
                    return ((String)o1).compareTo((String)o2);
                }else{
                    return ((String) o2).length()-((String) o1).length();
                }
            }
        });
//        Collections.sort(dictionary,new Comparator(){
//            public int compare(Object o1,Object o2){
//                if(((String)o1).length()>((String)o2).length()){
//                    return -1;
//                }else{
//                    return ((String)o1).compareTo((String)o2);
//                }
//            }
//        });
        int i,j,k = 0;
        for(i = 0;i<dictionary.size();i++){
            String tmp = dictionary.get(i);
            for(k = 0,j = 0;j<s.length() && k<tmp.length();j++){
                if(tmp.charAt(k)==s.charAt(j)){
                    k++;
                }
            }
            if(k == tmp.length()){
                return tmp;
            }
        }
        return "";
    }
    public static int[] smallestMissingValueSubtree(int[] parents, int[] nums) {
        Map<Integer,List<Integer>> map = new HashMap();
        Map<Integer,int[]> project = new HashMap<>();
        for (int i = 0;i<parents.length;i++){
            project.put(i,new int[]{parents[i],nums[i]});
        }
        Arrays.sort(parents);
        for(int i = 0;i<parents.length;i++){
            List<Integer> listTmp = new ArrayList();
            listTmp.add(i);
            for(int j = i+1;j<parents.length;j++){
                int tmp = parents[j];
                while(tmp!=i&&tmp!=-1){
                    tmp = parents[tmp];
                }
                if(tmp!=-1)
                    listTmp.add(project.get(j)[0]);
            }
            map.put(i,listTmp);
        }
        int []res = new int[parents.length];
        for(int k:map.keySet()){
            List<Integer> list = map.get(k);
            PriorityQueue<Integer> queue = new PriorityQueue((x,y)->(int)x-(int)y);
            for(int i = 0;i<list.size();i++){
                queue.offer(nums[list.get(i)]);
            }
            int i;
            for(i = 1;!queue.isEmpty();i++){
                if(i!=queue.poll()){
                    res[k] = i;
                    break;
                }
            }
            if(queue.isEmpty()&&res[k]==0){
                res[k] = i;
            }
        }
        return res;
    }
    public static int findIntegers(int n) {
        String str = getBinary(n);
        int res = 0;
        int[] dp = new int[32];
        dp[0] = 1;
        dp[1] = 2;
        dp[2] = 3;
        for(int i = 3;i<32;i++){
            dp[i] = dp[i-1]+dp[i-2];
        }
        for(int i = 0;i<str.length();i++){
            if(str.charAt(i)=='0'){
                continue;
            }
            res += dp[str.length()-i-1];
            if(i!=0 && str.charAt(i-1)=='1'){
                return res;
            }
        }
        return res+1;
    }
    public static String getBinary(int n){
        StringBuilder sb =new StringBuilder();
        while(n>0){
            sb.insert(0,n&1);
            n = n>>1;
        }
        return sb.toString();
    }
    public static int nthUglyNumber(int n) {
        long[] factors = new long[]{2,3,5};
        Set<Long> set = new HashSet();
        set.add(1l);
        PriorityQueue<Long> queue = new PriorityQueue(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if((long)o1>(long)o2){
                    return 1;
                }else{
                    return -1;
                }
            }
        });
        queue.offer(1l);
        long tmp = -1;
        int j = 1;
        while(j<=n){
            tmp = queue.poll();
            j++;
            for(int i = 0;i<3;i++){
                long possible = (long)tmp*factors[i];
                if(!set.contains(possible)){
                    set.add(possible);
                    queue.offer(possible);
                }
            }
        }
        return (int)tmp;
    }
    public static int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        List<int[]> list = new ArrayList();
        for(int i = 0;i<profits.length;i++){
            list.add(new int[]{profits[i],capital[i]});
        }
        Collections.sort(list,(a,b)->{return a[0]-b[0];});
        PriorityQueue<Integer> queue = new PriorityQueue<>((x, y) -> y - x);
        int sum = 0;
        int w1 = w;
        int j = 0;
        for(int i = 0;i<k;i++){
            while(j<list.size()&&w1>=list.get(j)[1]){
                queue.offer(list.get(j)[0]);
                j++;
            }
            int tmp = queue.peek();
            sum += tmp;
            w1 += tmp;
        }
        return sum;
    }
    public static List<List<String>> displayTable(List<List<String>> orders) {
        Map<String,Map<String,Integer>> menu = new HashMap();
        Set<String> tableSet = new HashSet();
        Set<String> menuSet = new HashSet();
        List<List<String>> res = new ArrayList();
        for(List<String> row:orders){
            if(tableSet.contains(row.get(1))){
                Map<String,Integer> tmpMap = menu.get(row.get(1));
                if(tmpMap.containsKey(row.get(2))){
                    int num = tmpMap.get(row.get(2));
                    tmpMap.put(row.get(2),++num);
                }else{
                    tmpMap.put(row.get(2),1);
                }
            }else{
                tableSet.add(row.get(1));
                Map<String,Integer> tmpMap = new HashMap<>();
                tmpMap.put(row.get(2),1);
                menu.put(row.get(1),tmpMap);
            }
            if(!menuSet.contains(row.get(2))){
                menuSet.add(row.get(2));
            }
        }
        ArrayList<String> table = new ArrayList(tableSet);
        Collections.sort(table, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                int i1 = Integer.valueOf(o1);
                int i2 = Integer.valueOf(o2);
                return i1-i2;
            }
        });
        ArrayList<String> menulist = new ArrayList(menuSet);
        Collections.sort(menulist);
        ArrayList<String>tmp = new ArrayList();
        tmp.add("Table");
        tmp.addAll(menulist);
        List<String> copyList1 = new ArrayList(tmp);
        res.add(copyList1);
        tmp.clear();
        for(int i = 0;i<table.size();i++){
            Map<String,Integer> map = menu.get(table.get(i));
            tmp.add(table.get(i));
            for(int j = 0;j<menulist.size();j++){
                if(map.containsKey(menulist.get(j))){
                    tmp.add(map.get(menulist.get(j))+"");
                }else{
                    tmp.add("0");
                }
            }
            List<String> copyList = new ArrayList(tmp);
            res.add(copyList);
            tmp.clear();
        }
        return res;
    }
    public static int fib(int n) {
        //
        if(n==0){
            return 0;
        }
        if(n==1){
            return 1;
        }
        long n0 = 0;
        long n1 = 1;
        long tmp = 1;
        for(int i = 2;i<=n;i++){
            tmp = n0+n1;
            n0 = n1;
            n1 = tmp;
            System.out.println(tmp);
        }
        return (int)tmp%(1000000007);
    }
    public static int compareVersion(String version1, String version2) {
        String[] s1 = version1.split("\\.");
        String[]s2 = version2.split("\\.");
        int i;
        for(i = 0;i<s1.length&&i<s2.length;i++){
            if(Integer.valueOf(s1[i])==Integer.valueOf(s2[i])){
                continue;
            }else if(Integer.valueOf(s1[i])<Integer.valueOf(s2[i])){
                return -1;
            }else{
                return 1;
            }
        }
        while(i<s1.length){
            if(Integer.valueOf(s1[i])!=0){
                return 1;
            }
        }
        while(i<s2.length){
            if(Integer.valueOf(s2[i])!=0){
                return -1;
            }
        }
        return 0;
    }
    public static int sumOddLengthSubarrays(int[] arr) {
        int []count = new int[arr.length];
        int sum = 0;
        for(int i = 1;i<=arr.length;i+=2){//k
            for(int j = 0;j+i<=arr.length;j++){//
                for(int k = j;k<j+i;k++){
                    count[k]++;
                }
            }
        }
        for(int i = 0;i<arr.length;i++){
            sum+=count[i]*arr[i];
        }
        return sum;
    }
    public static boolean isPeak(int[][]mat,int i,int j){
        boolean flag = true;
        if(i-1>0){
            if(mat[i][j]<=mat[i-1][j]){
                flag = false;
            }
        }
        if(i+1<mat.length){
            if(mat[i][j]<=mat[i+1][j]){
                flag = false;
            }
        }
        if(j-1>0){
            if(mat[i][j]<=mat[i][j-1]){
                flag = false;
            }
        }
        if(j+1<mat[0].length){
            if(mat[i][j]<=mat[i][j+1]){
                flag = false;
            }
        }
        return flag;
    }
    public static int[] fun(int [][]mat,int i,int start,int end){
        if(start<=end){
            int mid = (end-start)/2+start;
            if(isPeak(mat,i,mid)){
                return new int[]{i,mid};
            }
            int tmp[] = fun(mat,i,start,mid-1);
            if(tmp[0]!=-1){
                return tmp;
            }
            tmp = fun(mat,i,mid+1,end);
            if(tmp[0]!=-1){
                return tmp;
            }
            return new int[]{-1,-1};
        }
        return new int[]{-1,-1};
    }
    public static int[] findPeakGrid(int[][] mat) {
        for(int i = 0;i<mat.length;i++){

            int tmp[] = fun(mat,i,0,mat[0].length-1);
            if(tmp[0]!=-1){
                return tmp;
            }
        }
        return new int[]{-1,-1};
    }
    public static boolean isVowel(char c){
        switch(c){
            case 'a':return true;
            case 'e':return true;
            case 'i':return true;
            case 'o':return true;
            case 'u':return true;
        }
        return false;
    }
    public static int maxVowels_1456(String s, int k) {
        int num = 0;
        int max = 0;
        for(int i = 0;i<k;i++){
            if(isVowel(s.charAt(i))){
                num++;
            }
        }
        max = num;
        for(int j = k;j<s.length();j++){
            if(isVowel(s.charAt(j))){
                num++;
            }
            if(isVowel(s.charAt(j-k))){
                num--;
            }
            max = Math.max(num,max);
        }
        return max;
    }
    public static int fun(int[] nums,int s,int e){
        int start = s;
        int end = e;
        int mid ;
        if(start<=end){
            mid = (end-start)/2+start;
            if(nums[mid]>nums[mid+1]&&nums[mid]>nums[mid-1]){
                return mid;
            }
            int tmp = fun(nums,mid+1,e);
            if(tmp!=-1){
                return tmp;
            }
            tmp = fun(nums,start,mid-1);
            if(tmp!=-1){
                return tmp;
            }
        }
        return -1;
    }
    public static int findPeakElement(int[] nums) {
        //
        if(nums.length==1){
            return 0;
        }
        int tmp = fun(nums,1,nums.length-2);
        if(tmp==-1){
            if(nums[0]>nums[nums.length-1]){
                return 0;
            }else{
                return nums.length-1;
            }
        }
        return tmp;
    }
    public static void dfs(Set<List<Integer>>resSet,List<Integer>nums,List<Integer> tmp){
        if(nums.size()==0){
            List<Integer> copy = new ArrayList<>(tmp);
            resSet.add(copy);
            return;
        }
        for(int i = 0;i<nums.size();i++){
            tmp.add(nums.remove(i));
            dfs(resSet,nums,tmp);
            int temp = tmp.remove(tmp.size()-1);
            nums.add(i,temp);
        }
    }
    public static List<List<Integer>> permuteUnique(int[] nums) {
        //List<List<Integer>>res = new ArrayList();
        Set<List<Integer>>resSet = new HashSet();
        List<Integer> numsList = new ArrayList();
        for(int i = 0;i<nums.length;i++){//list
            numsList.add(nums[i]);
        }
        List<Integer> tmp = new ArrayList();
        dfs(resSet,numsList,tmp);
        return new ArrayList<List<Integer>>(resSet);
    }
    public static int dfs(Map<Integer,List<int[]>>flights,int k,int src,int dst){
        if(src==dst){
            return 0;
        }
        if(k==-1){
            return -1;
        }
        if(flights.containsKey(src)){
            List<int[]> edges = flights.get(src);
            int shortestEdge = Integer.MAX_VALUE/2;
            for(int i = 0;i<edges.size();i++){
                int newSrc = edges.get(i)[1];
                int tmp = dfs(flights,k-1,newSrc,dst);
                if(tmp!=-1){
                    shortestEdge = Math.min(shortestEdge,tmp + edges.get(i)[2]);
                }
            }
            return shortestEdge;
        }else{
            return -1;
        }
        //return -1;
    }
    public static int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        Map<Integer,List<int[]>>map = new HashMap();
        for(int i = 0;i<flights.length;i++){
            if(map.containsKey(flights[i][0])){
                map.get(flights[i][0]).add(flights[i]);
            }else{
                List<int[]> tmpList = new ArrayList();
                tmpList.add(flights[i]);
                map.put(flights[i][0],tmpList);
            }
        }
        //List<int[]> list = map.get(src);
        return dfs(map,k,src,dst);
    }
    public static int countDigitOne(int n) {
        // int res = 0;
        // for(int i = 1;i<=n;i++){
        //     res += divided(i);
        // }
        // return res;
        int []res = new int[9];
        //int []res1 = new int[9];
        int count = 0;
        res[0] = 1;
        res[1] = 20;
        int bigData9 = 1000000000;
        int bigData8 = 100000000;
        int bigData7 = 10000000;
        int bigData6 = 1000000;
        int bigData5 = 100000;
        int bigData4 = 10000;
        int bigData3 = 1000;
        int bigData2 = 100;
        int bigData1 = 10;
        for(int i = 2;i<9;i++){
            res[i] = res[i-1]*10+(int)Math.pow(10,i);
        }
        if(n==bigData9){
            count += res[8];
            return count+1;
        }
        while(n>0){
            if(n>=bigData8){
                if(n>=bigData8*2){
                    count += bigData8;
                    int tmp = n/bigData8;
                    count += tmp * res[7];
                }else{
                    count += n-bigData8+1+res[7];

                }
                //count += res[7];
                n = n%bigData8;
            }else if(n>=bigData7){
                //count += res[6];
                if(n>=bigData7*2){
                    int tmp = n/bigData7;
                    count += tmp * res[6];
                    count += bigData7;
                }else{
                    count += n-bigData7+1+res[6];
                }
                n = n%bigData7;
            }else if(n>=bigData6){
                //count += res[5];
                if(n>=bigData6*2){
                    count += bigData6;
                    int tmp = n/bigData6;
                    count += tmp * res[5];
                }else{
                    count += n-bigData6+1+res[5];
                }
                n = n%bigData6;
            }else if(n>=bigData5){
                if(n>=bigData5*2){
                    count += bigData5;
                    int tmp = n/bigData5;
                    count += tmp * res[4];
                }else{
                    count += n-bigData5+1+res[4];
                }
                //count += res[4];
                n = n%bigData5;
            }else if(n>=bigData4){
                if(n>=bigData4*2){
                    count += bigData4;
                    int tmp = n/bigData4;
                    count += tmp*res[3];
                }else{
                    count += n-bigData4+1+res[3];
                }
                //count += res[3];
                n = n%bigData4;
            }else if(n>=bigData3){
                if(n>=bigData3*2){
                    count += bigData3;
                    int tmp = n/bigData3;
                    count += tmp*res[2];
                }else{
                    count += n-bigData3+1+res[2];
                }
                //count += res[2];
                n = n%bigData3;
            }else if(n>=bigData2){
                if(n>=bigData2*2){
                    count += bigData2;
                    int tmp = n/bigData2;
                    count += tmp*res[1];
                }else{
                    count += n-bigData2+1+res[1];
                }
                //count += res[1];
                n = n%bigData2;
            }else if(n>=bigData1){
                if(n >=bigData1*2){
                    count += bigData1;
                    int tmp = n/bigData1;
                    count += tmp*res[0];
                }else{
                    count += n-bigData1+1+res[0];
                }
                //count += res[0];
                n = n%bigData1;
            }else if(n>=1){
                count += 1;
                n = n%1;
            }
        }
        return count;
    }
    public static int nthUglyNumberDynamic(int n){
        int p2 = 1;
        int p3 = 1;
        int p5 = 1;
        int []res = new int[n+1];
        res[0] = 1;
        for(int i = 1;i<=n;i++){
            res[i] = Math.min(Math.min(res[p2]*2,res[p3]*3),res[p5]*5);

        }
        return 0;
    }
    public static int compress(char[] chars){
        int write = 0;
        int partLength = 0;
        int start = 0;
        int tmp = 0;
        for(int i = 0;i<chars.length;i++){
            if(i==chars.length-1||chars[i]!=chars[i+1]){
                chars[write++] = chars[i];
                partLength = i-start+1;
                tmp = write;
                if(partLength>1){
                    while(partLength>0){
                        chars[write++] = (char)(partLength%10+'0');
                        partLength  = partLength/10;
                    }
                    reverse(chars,tmp,write-1);
                }
                start = i+1;
            }
        }

        return write;
    }
    public static void reverse(char[]chars,int start,int end){
        while(start<end){
            char tmp = chars[start];
            chars[start] = chars[end];
            chars[end] = tmp;
            start++;
            end--;
        }
    }
    public static String reverseStr(String s, int k) {
        char []res = new char[s.length()];
        int end = s.length();
        int i = 0;
        int lastEnd = 0;
        for(int j = -1;i<end;i++){
            if(i%k==0){
                j++;
                lastEnd = i;
            }
            if(j%2==0){
                if(end-lastEnd<k){
                    break;
                }else{
                    res[j*k+k-i%k-1] = s.charAt(i);
                }
            }else{
                res[i] = s.charAt(i);
            }
            //res[end-i-1] = s.charAt(i);
        }
        for(int j = i;j<end;j++){
            res[end-j%k-1] = s.charAt(i);
        }
        return new String(res);
    }
    public static boolean isPowerOfTwo(int n) {
        if(n<1)
            return false;
        int start = 0,end = n-1;
        int mid;
        while(start<=end){
            mid = (end-start)/2+start;
            double tmp = (double) Math.pow(2,mid);
            System.out.println(tmp);
            if(tmp==n)return true;
            else if(tmp<n) start = mid+1;
            else end = mid-1;
        }
        return false;
    }
    public static boolean isAEIOU(char ch){
        switch(ch){
            case 'a':return true;
            case 'e':return true;
            case 'i':return true;
            case 'o':return true;
            case 'u':return true;
            case 'A':return true;
            case 'E':return true;
            case 'I':return true;
            case 'O':return true;
            case 'U':return true;
            default:return false;
        }
    }
    public static String reverseVowels(String s) {
        char[] chs = new char[s.length()];
        List<Character> stack = new ArrayList();
        for(int i = 0;i<s.length();i++){
            if(isAEIOU(s.charAt(i))){
                stack.add(s.charAt(i));
            }else{
                chs[i] = s.charAt(i);
            }
        }
        StringBuilder stringBuilder = new StringBuilder();
        for(int i = 0,j = stack.size()-1;i<chs.length;i++){
            if(chs[i]==0){
                stringBuilder.append(stack.get(j--));
            }else{
                stringBuilder.append(chs[i]);
            }
        }
        return stringBuilder.toString();
    }

    public static int[] checkHeap(int[] nums, int i) {
        for (int j = i; j <= (nums.length - 1) / 2; j++) {
            if (nums[j] < nums[2 * j]) {
                if (2 * j + 1 < nums.length) {
                    if (nums[j] < nums[2 * j + 1]) {
                        continue;
                    } else {
                        return new int[]{j, nums[j], nums[2 * j + 1]};
                    }
                }
            } else {
                return new int[]{j, nums[j], nums[2 * j]};
            }
        }
        return new int[]{0, 0, 0};
    }

    private static void adjustDownToUp(int[] array, int k, int length) {
        int temp = array[k];
        for (int i = 2 * k; i < length; i = 2 * i) {    //ik
            if (i < length - 1 && array[i] > array[i + 1]) {  //
                i++;   //>
            }
            if (temp <= array[i]) {  // >=
                break;
            } else {   // <
                array[k] = array[i];  //array[i]
                k = i; //k
            }
        }
        array[k] = temp;  //
    }

    public static void adjustDown(int[] heap, int i, int end) {
        int tmp = heap[i];
        while (i * 2 < end) {
            int left = 2 * i;
            int min = i;
            if (left+1 < end && heap[left+1]<heap[left]) {
                min = left+1;
            }else{
                min = left;
            }
            if(tmp<=heap[min]){
                break;
            }else{
                heap[i] = heap[min];
                i = min;
            }
        }
        heap[i] = tmp;
        //swap(heap,i,min);

    }

    public static int findKthLargest(int[] nums, int k) {
        // Arrays.sort(nums);
        // return nums[nums.length-k];
        int heap[] = new int[k + 1];
        int len = 1;
        for (int i = 0; i < k; i++) {
            heap[len++] = nums[i];
        }
        for (int i = k / 2; i >= 1; i--) {//
            adjustDownToUp(heap, i, len);
        }
        int[] arr2 = checkHeap(heap, 1);
        //System.out.println(arr2[0]+" "+arr2[1]+" "+arr2[2]);
        for (int i = k; i < nums.length; i++) {
            if (heap[1] < nums[i]) {
                heap[1] = nums[i];
                adjustDownToUp(heap, 1, len);
            }
        }

        return heap[1];
    }

    public static void backtracking(int numA, int numL, int len, int n) {
        if (numA == 2 || numL == 3) {
            return;
        } else {
            if (len == n) {
                nums++;
            } else {
                backtracking(numA + 1, 0, len + 1, n);
                backtracking(numA, numL + 1, len + 1, n);
                backtracking(numA, numL, len + 1, n);
            }
        }
    }

    public static int checkRecord(int n) {
        backtracking(1, 0, 1, n);
        backtracking(0, 1, 1, n);
        backtracking(0, 0, 1, n);
        return nums % MOD;
    }

    public static void backtracking(int x, int y, int maxMove, int m, int n) {
        if (maxMove >= 0) {
            if (x < 0 || y < 0 || x >= m || y >= n) {
                nums++;
                return;
            } else {
                //List<int[]>tmpUp = new ArrayList(tmp);
                //tmp.add(new int[]{x-1,y});
                backtracking(x - 1, y, maxMove - 1, m, n);//up
                //tmp.remove(tmp.size()-1);

                //List<int[]>tmpDown = new ArrayList(tmp);
                //tmp.add(new int[]{x+1,y});
                backtracking(x + 1, y, maxMove - 1, m, n);//down
                //tmp.remove(tmp.size()-1);

                //List<int[]>tmpLeft = new ArrayList(tmp);
                //tmp.add(new int[]{x,y-1});
                backtracking(x, y - 1, maxMove - 1, m, n);//left
                //tmp.remove(tmp.size()-1);

                //List<int[]>tmpRight = new ArrayList(tmp);
                //tmp.add(new int[]{x,y+1});
                backtracking(x, y + 1, maxMove - 1, m, n);//right
                //tmp.remove(tmp.size()-1);
                return;
            }
            // if(){
            //     List<int[]>tmp2 = new ArrayList(tmp);
            //     tmp2.add(new int[]{x,y});
            //     setResult.add(tmp2);
            //     return;
            // }
        } else {
            return;
        }

    }

    public static int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        //Set<List<int[]>> setResult = new HashSet();
        //List<int[]>tmp = new ArrayList();
        //tmp.add(new int[]{startRow,startColumn});
        int x = startRow, y = startColumn;

        //List<int[]>tmpUp = new ArrayList(tmp);
        //tmpUp.add(new int[]{x-1,y});
        backtracking(x - 1, y, maxMove - 1, m, n);//up
        //tmpUp.remove(tmpUp.size()-1);

        //List<int[]>tmpDown = new ArrayList(tmp);
        //tmpDown.add(new int[]{x+1,y});
        backtracking(x + 1, y, maxMove - 1, m, n);//down
        //tmpDown.remove(tmpDown.size()-1);

        //List<int[]>tmpLeft = new ArrayList(tmp);
        //tmpLeft.add(new int[]{x,y-1});
        backtracking(x, y - 1, maxMove - 1, m, n);//left
        //tmtmpLeftp.remove(tmp.size()-1);

        //List<int[]>tmpRight = new ArrayList(tmp);
        //tmpRight.add(new int[]{x,y+1});
        backtracking(x, y + 1, maxMove - 1, m, n);//right
        //tmp.remove(tmpRight.size()-1);
        return nums % (1000000007);
    }

    public static void backtracking(Map<Integer, Boolean> map, int n, int k) {
        if (k == n) {
            nums++;
            return;
        }
        for (int i = 1; i <= n; i++) {
            if (map.get(i) == true) {
                if (i % (k + 1) == 0 || (k + 1) % i == 0) {
                    map.put(i, false);
                    backtracking(map, n, k + 1);
                    map.put(i, true);
                }
            }
        }

    }

    public static int countArrangement(int n) {
        //String num = "";
        Map<Integer, Boolean> map = new HashMap();
        for (int i = 1; i <= n; i++) {
            map.put(i, true);
        }
        for (int i = 1; i <= n; i++) {
            map.put(i, false);
            backtracking(map, n, 1);
            map.put(i, true);
        }
        return nums;
    }

    public static int numIslands(char[][] grid) {
        //dfs
        // int m = grid.length;
        // int n = grid[0].length;
        // int num = 0;
        // for(int i = 0;i<m;i++){
        //     for(int j = 0;j<n;j++){
        //         if(grid[i][j]=='1'){
        //             dfs(grid,m,n,i,j);
        //             num++;
        //         }
        //     }
        // }
        // return num;
        //BFS
        Queue<int[]> q = new LinkedList();
        int num = 0;
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    int[] coordinary = new int[]{i, j};
                    q.offer(coordinary);
                    BFS(grid, q, m, n);
                    num++;
                }
            }
        }
        return num;
    }

    public static int minSubArrayLen(int target, int[] nums) {
        int minlen = Integer.MAX_VALUE;
        int sum = 0;
        for (int i = 0, j = 0; i < nums.length; ) {
            if (sum < target) {
                if (j == nums.length) {
                    break;
                } else {
                    sum += nums[j];
                    j++;
                }

            } else {
                minlen = Math.min(minlen, j - i);
                sum -= nums[i];
                i++;
            }
        }
        if (minlen < nums.length) {
            return minlen;
        } else {
            return 0;
        }
    }

    public static void BFS(char[][] grid, Queue<int[]> q, int m, int n) {
        while (q.size() > 0) {
            int[] tmpCoordinary = q.poll();
            int x = tmpCoordinary[0];
            int y = tmpCoordinary[1];

            grid[x][y] = '0';
            if (x - 1 >= 0) {//
                if (grid[x - 1][y] == '1') {
                    q.offer(new int[]{x - 1, y});
                }
            }
            if (x + 1 < m) {//
                if (grid[x + 1][y] == '1') {
                    q.offer(new int[]{x + 1, y});
                }
            }
            if (y - 1 >= 0) {//
                if (grid[x][y - 1] == '1') {
                    q.offer(new int[]{x, y - 1});
                }
            }
            if (y + 1 < n) {//
                if (grid[x][y + 1] == '1') {
                    q.offer(new int[]{x, y + 1});
                }
            }
        }


    }

    public static int majorityElement(int[] nums) {
        //
        // Arrays.sort(nums);
        // return nums[nums.length/2];
        //HashMap
        Map<Integer, Integer> map = new HashMap();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {
                map.put(nums[i], map.get(nums[i]) + 1);
            } else {
                map.put(nums[i], 1);
            }
        }
        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();
        Map.Entry en = it.next();
        int maxCurrence = (int) en.getKey();
        int maxNums = (int) en.getValue();
        while (it.hasNext()) {
            en = it.next();
            if (maxNums < (int) en.getValue()) {
                maxCurrence = (int) en.getKey();
            }
        }
        return maxCurrence;
    }

    public static List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        Set<List<Integer>> setResult = new HashSet();
        //List<List<Integer>> res = new ArrayList();
        setResult.add(new ArrayList());
        for (int i = 0; i < nums.length; i++) {
            Set<List<Integer>> setTmp = new HashSet();
            Iterator<List<Integer>> iterator = setResult.iterator();
            while (iterator.hasNext()) {
                setTmp.add(new ArrayList<>(iterator.next()));
            }
            for (List<Integer> l : setTmp) {
                l.add(nums[i]);
                setResult.add(l);
            }

        }
        return new ArrayList(setResult);
    }

    public static int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> res = new ArrayList();
        if (intervals.length == 0) {
            return new int[][]{newInterval};
        }
        for (int i = 0; i < intervals.length; i++) {
            if (newInterval[0] > intervals[i][1]) {
                res.add(intervals[i]);
            } else {
                int[] tmp = new int[2];
                tmp[0] = intervals[i][0];
                //int j;
                for (; i < intervals.length; i++) {
                    if (newInterval[1] <= intervals[i][1] && newInterval[1] > intervals[i][0]) {
                        tmp[1] = intervals[i][1];
                        res.add(tmp);
                        i++;
                        break;
                    } else if (newInterval[1] < intervals[i][0]) {
                        tmp[1] = newInterval[1];
                        res.add(tmp);
                        break;
                    }
                }
                if (i == intervals.length) {
                    if (newInterval[1] > intervals[i - 1][1]) {
                        tmp[1] = newInterval[1];
                        res.add(tmp);
                    }
                }
                if (i < intervals.length) {
                    //res.add(tmp);
                    for (; i < intervals.length; i++) {
                        res.add(intervals[i]);
                    }
                }
            }
        }
        return res.toArray(new int[res.size()][2]);
    }

    public static int[][] merge(int[][] arr1) {
        Arrays.sort(arr1, (a, b) -> a[0] - b[0]);
//        for (int i = 0; i < arr1.length; i++) {
//            for (int j = 0; j < arr1[i].length; j++) {
//                System.out.print(arr1[i][j]+" ");
//            }
//            System.out.println();
//        }
        List<int[]> res = new ArrayList<>();
        res.add(arr1[0]);
        for (int i = 1; i < arr1.length; i++) {
            if (arr1[i][0] > res.get(res.size() - 1)[1]) {//
                res.add(arr1[i]);
            } else {
                int tmp = res.get(res.size() - 1)[1];
                res.get(res.size() - 1)[1] = Math.max(arr1[i][1], tmp);
            }
        }
        int[][] tmp = res.toArray(new int[res.size()][2]);
        for (int i = 0; i < tmp.length; i++) {
            for (int j = 0; j < tmp[i].length; j++) {
                System.out.print(tmp[i][j] + " ");
            }
            System.out.println();
        }
        return null;
    }

    public static void backTracking(int[] nums, Map<Integer, Boolean> visited, List<Integer> list, List<List<Integer>> result) {
        if (list.size() == nums.length) {
            List<Integer> copyList = new ArrayList(list);
            result.add(copyList);
        }
        for (int i = 0; i < nums.length; i++) {
            if (!visited.get(nums[i])) {
                visited.put(nums[i], true);
                //copyList.add(nums[i]);
                list.add(nums[i]);
                backTracking(nums, visited, list, result);
                list.remove(list.size() - 1);
                visited.put(nums[i], false);
            }
        }
    }

    public static List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        Map<Integer, Boolean> visited = new HashMap();
        List<List<Integer>> result = new ArrayList();
        List<Integer> list = new ArrayList();
        for (int num : nums) {
            visited.put(num, false);
        }
        for (int i = 0; i < len; i++) {
            if (visited.get(nums[i]) == false) {
                visited.put(nums[i], true);
                list.add(nums[i]);
                backTracking(nums, visited, list, result);
                list.remove(list.size() - 1);
                visited.put(nums[i], false);
            }
        }
        return result;
    }

    public static String fun(char[] chs) {
        StringBuilder strBuilder = new StringBuilder();
        for (int i = 0; i < chs.length; i++) {
            strBuilder.append("#");
            strBuilder.append(chs[i] + 0);
            chs[i] = 0;
        }
        return strBuilder.toString();
    }

    public static List<List<String>> groupAnagrams(String[] strs) {
        char[] chs = new char[128];
        Map<String, List<String>> map = new HashMap();
        List<List<String>> resultList = new ArrayList<List<String>>();
        for (String str : strs) {
            for (int i = 0; i < str.length(); i++) {
                chs[str.charAt(i)] += 1;
            }
            String chCode = fun(chs);//charToString and reset chs
            if (map.containsKey(chCode)) {
                map.get(chCode).add(str);
            } else {
                List<String> list = new ArrayList<>();
                list.add(str);
                map.put(chCode, list);
            }
        }
        for (List<String> l : map.values()) {
            resultList.add(l);
        }
        return resultList;
    }

    public static void dfs(List<String> list, String str, int left, int right) {
        if (left > right) {
            return;
        }
        if (left == 0 && right == 0) {
            list.add(str);
        }
        if (left > 0) {
            dfs(list, str + "(", left - 1, right);
        }
        if (right > 0) {
            dfs(list, str + ")", left, right - 1);
        }
    }

    public static List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList();
        //int leftRemained  = n;
        //int rightRemained = n;
        //List<String> tmpList = new ArrayList();
        dfs(result, "", n, n);
        return result;
    }


    public static int[] closestRoom(int[][] rooms, int[][] queries) {
        Arrays.sort(rooms, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o2[1] - o1[1];
            }
        });
        Arrays.sort(queries, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o2[1] - o1[1];//
            }
        });
        List<Integer> list1 = new ArrayList<Integer>();
        int[] result = new int[queries.length];
        int j = 0;
        for (int i = 0; j < queries.length && i < rooms.length; ) {
            if (queries[j][1] > rooms[i][1]) {
                //result.add(-1);
                if (list1.size() == 0) {
                    result[j] = -1;
                    j++;
                } else {
                    int[] index = binary_Search(list1, queries[j][0]);
                    result[j] = index[1];
                    j++;
                }

            } else {
                insert(list1, rooms[i][0]);
                i++;
            }
        }
        while (j < queries.length) {
            int[] index = binary_Search(list1, queries[j][0]);
            result[j] = index[1];
            j++;
        }
        return result;
    }

    public static void insert(List<Integer> list, int num) {//num,
        int i = 0;
        for (; i < list.size(); i++) {
            if (num < list.get(i)) {
                break;
            }
        }
        list.add(i, num);
    }

    public static int[] binary_Search(List<Integer> list, int num) {
        int start = 0, end = list.size() - 1;
        int mid = 0;
        while (start <= end) {
            mid = (end - start) / 2 + start;
            if (list.get(mid) == num) return new int[]{1, list.get(mid)};
            else if (list.get(mid) < num) start = mid + 1;
            else end = mid - 1;
        }
        return new int[]{-1, list.get(mid)};
    }

    public static String[] arrayToString(int[] nums) {//-1null
        String[] strArray = new String[nums.length];
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == -1) {
                strArray[i] = "null";
            } else {
                strArray[i] = nums[i] + "";
            }
        }
        return strArray;
    }

    public static void midOrder(TreeNode root) {
        if (root != null) {
            midOrder(root.left);
            System.out.println(root.val);
            midOrder(root.right);
        }
    }

    public static TreeNode createTree(String[] nums) {
        TreeNode root = null;
        //TreeNode tmp = null;
        if (nums.length <= 0) {
            return null;
        }
        Queue<TreeNode> q = new LinkedList<>();
        root = new TreeNode();
        root.val = nums[0];
        q.offer(root);
        for (int i = 1; i < nums.length - 1; i++) {
            TreeNode tmp = q.poll();
            TreeNode tmpLetf = null;
            TreeNode tmpRight = null;
            if (nums[i] != "null") {
                tmpLetf = new TreeNode();
                tmpLetf.val = nums[i];
            }
            if (nums[++i] != "null") {
                tmpRight = new TreeNode();
                tmpRight.val = nums[i];
            }
            tmp.left = tmpLetf;
            tmp.right = tmpRight;
            if (tmpLetf != null)
                q.offer(tmpLetf);
            if (tmpRight != null)
                q.offer(tmpRight);
        }
        return root;
    }

    public static int[] dfs(TreeNode root) {
        if (root == null) {
            return new int[]{0, 0};
        }
        int[] l = dfs(root.left);
        int[] r = dfs(root.right);
        int noselect = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
        int select = root.value + l[1] + r[1];
        return new int[]{select, noselect};
    }

    public static int robRecurve(int[] nums, int index) {
        if (index == 0) {
            return nums[0];
        }
        if (index < 0) {
            return 0;
        }
        return Math.max(robRecurve(nums, index - 1), nums[index] + robRecurve(nums, index - 2));
    }

    public static int rob(int[] nums) {
        int length = nums.length;
        int maxMoney[] = new int[length];
        if (length == 1) {
            return nums[0];
        }
        if (length == 2) {
            return Math.max(nums[0], nums[1]);
        }
        maxMoney[0] = nums[0];
        maxMoney[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < length; i++) {
            maxMoney[i] = Math.max(maxMoney[i - 1], nums[i] + maxMoney[i - 2]);
        }
        return maxMoney[length - 1];
    }

    public static boolean fun(String[] board, char rule) {//
        for (int i = 0; i < board.length; i++) {//
            int j = 0;
            for (; j < board.length; j++) {
                if (rule != board[i].charAt(j)) {
                    break;
                }
            }
            if (j == board.length) {
                return true;
            }
        }
        for (int i = 0; i < board.length; i++) {//
            int j = 0;
            for (; j < board.length; j++) {
                if (board[j].charAt(i) != rule) {
                    break;
                }
            }
            if (j == board.length) {
                return true;
            }
        }
        int line = 0;
        for (int j = 0; line < board.length && j < board.length; line++, j++) {// \
            if (board[line].charAt(j) != rule) {
                break;
            }
        }
        if (line == board.length) {
            return true;
        }
        line = 0;
        for (int j = board.length - 1; line < board.length && j >= 0; line++, j--) {// /
            if (board[line].charAt(j) != rule) {
                break;
            }
        }
        if (line == board.length) {
            return true;
        }
        return false;
    }

    public static String tictactoe(String[] board) {
        int X = 0, O = 0;
        for (int i = 0; i < board.length; i++) {//
            for (int j = 0; j < board.length; j++) {
                if (board[i].charAt(j) == 'X') {
                    X++;
                } else if (board[i].charAt(j) == 'O') {
                    O++;
                }
            }
        }
        if (X - O == 1) {
            if (fun(board, 'X')) {
                return "X";
            } else if (X == board.length * board.length / 2 + 1) {
                return "Draw";
            } else {
                return "Pending";
            }

        } else if (X - O == 0) {
            if (fun(board, 'O')) {
                return "O";
            } else if (fun(board, 'X')) {
                return "X";
            } else if (X != board.length * board.length / 2) {
                return "Pending";
            } else {
                return "Draw";
            }
        } else {
            if (fun(board, 'O')) {
                return "O";
            } else if (O == board.length * board.length / 2 + 1) {
                return "Draw";
            } else {
                return "Pending";
            }
        }
    }


    public static double champagneTower(int poured, int query_row, int query_glass) {
        double[][] champagen = new double[100][100];
        champagen[0][0] = poured;
        for (int i = 0; i < query_row; i++) {//
            for (int j = 0; j < i + 1; j++) {
                if (champagen[i][j] > 1) {
                    double tmp = champagen[i][j] - 1;
                    champagen[i][j] = 1;
                    champagen[i + 1][j] += tmp / 2;
                    champagen[i + 1][j + 1] += tmp / 2;
                }
            }
        }
        return champagen[query_row][query_glass] > 1 ? 1 : champagen[query_row][query_glass];
    }

    /**
     * @author:weilongzhao
     * @time:2021/7/15
     */
    public static void bfs(Queue<Integer> q, boolean[] visited, int[][] isConnected) {
        int citys = isConnected.length;
        if (q.isEmpty()) {
            return;
        }
        int i = q.poll();
        for (int j = 0; j < citys; j++) {
            if (isConnected[i][j] == 1 && visited[j] == false) {//ij
                visited[j] = true;
                q.offer(j);
            }
        }
        bfs(q, visited, isConnected);
    }

    public static int findCircleNum(int[][] isConnected) {
        // int citys = isConnected.length;//
        // boolean []visited = new boolean[citys];
        // int provinces = 0;
        // for(int i = 0;i<citys;i++){
        //     if(visited[i] == false){//
        //         visited[i] = true;
        //         dfs(i,visited,isConnected);
        //         provinces++;
        //     }
        // }
        // return provinces;
        //bfs
        int citys = isConnected.length;
        boolean[] visited = new boolean[citys];
        Queue<Integer> q = new LinkedList();
        int provinces = 0;
        for (int i = 0; i < citys; i++) {
            if (visited[i] == false) {//
                visited[i] = true;
                q.offer(i);
                bfs(q, visited, isConnected);
                provinces++;
            }
        }
        return provinces;
    }

    /**
     * @author:weilongzhao
     * @time:2021/7/15
     */
    private static int maxCircleOfTriangle(int[] arr) {
        Arrays.sort(arr);
        for (int i = arr.length - 1; i >= 2; i--) {
            if (arr[i] < arr[i - 1] + arr[i - 2]) {
                return arr[i] + arr[i - 1] + arr[i - 2];
            }
        }
        return -1;
    }

    private static boolean isCharge(int[] arr) {
        int five = 0, ten = 0;//50100

        for (int bill : arr) {
            if (bill == 5) {
                five++;
            } else if (bill == 10) {
                if (five > 0) {
                    five--;
                } else {
                    return false;
                }
            } else if (bill == 20) {
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                } else if (five >= 3) {
                    five -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    }

    private static int minDeep2(TreeNode root) {
        TreeNode[] nodeQueue = new TreeNode[100];
        TreeNode tmp = null;
        int level = 0;
        int first = -1, last = 0;
        int levelEnd = last;
        if (root == null) {
            return 0;
        }
        nodeQueue[last] = root;
        while (first < last) {
            tmp = nodeQueue[++first];
            if (tmp.left == null && tmp.right == null) {
                return level + 1;
            }
            if (tmp.left != null) {//
                nodeQueue[++last] = tmp.left;
            }
            if (tmp.right != null) {
                nodeQueue[++last] = tmp.right;
            }
            if (first == levelEnd) {//
                level++;
                levelEnd = last;
            }
        }
        return level;
    }

    private static int minDeep(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {//
            return 1;
        }
        int tmp1 = Integer.MAX_VALUE, tmp2 = Integer.MAX_VALUE;
        if (root.left != null) {
            tmp1 = minDeep(root.left);
        }
        if (root.right != null) {
            tmp2 = minDeep(root.right);
        }
        return Math.min(tmp1, tmp2) + 1;
    }

    private static TreeNode generate() {
//        TreeNode node7 = new TreeNode(7,null,null);
//        TreeNode node6 = new TreeNode(6,null,null);
//        TreeNode node5 = new TreeNode(5,null,null);
        TreeNode node4 = new TreeNode(3, null, null);
        TreeNode node3 = new TreeNode(2, node4, null);
        TreeNode node2 = new TreeNode(1, node3, null);
        TreeNode node1 = new TreeNode(4, node2, null);
        return node1;
    }

    private static int Fibonacci(int n) {
        if (n == 0) return 0;
        int[] arr = new int[n + 1];
        arr[0] = 0;
        arr[1] = 1;
        for (int i = 2; i <= n; i++) {
            arr[i] = arr[i - 1] + arr[i - 2];
        }
        return arr[n];
    }

    private static int Fibonacci2(int n) {
        int[] arr = new int[n + 1];

        return recurse(arr, n);
    }

    private static int recurse(int[] array, int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        if (array[n] != 0) {
            return array[n];
        }
        array[n] = recurse(array, n - 1) + recurse(array, n - 2);
        return array[n];
    }

    private static int[] twoNumsEqualsTarget(int[] arr, int target) {//HashMap 
        HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < arr.length; i++) {
            if (hashMap.containsKey(target - arr[i])) {
                return new int[]{i, hashMap.get(target - arr[i])};
            }
            hashMap.put(arr[i], i);
        }
        return new int[]{-1, -1};
    }

    private static double newton(double i, int x) {//
        double res = (i + x / i) / 2;
        if (res == i) {
            return res;
        }
        return newton(res, x);
    }

    private static int maxResultOfThereMultiple(int[] arr) {//,
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE - 1;
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE + 1, max3 = Integer.MIN_VALUE + 2;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < min1) {
                min2 = min1;
                min1 = arr[i];
            } else if (arr[i] < min2) {
                min2 = arr[i];
            }
            if (arr[i] > max1) {
                max3 = max2;
                max2 = max1;
                max1 = arr[i];
            } else if (arr[i] > max2) {
                max3 = max2;
                max2 = arr[i];
            } else if (arr[i] > max3) {
                max3 = arr[i];
            }
        }
        return Math.max(min1 * min2 * max1, max1 * max2 * max3);

    }

    private static int arrayCenterIndex(int[] arr) {
        int total = 0;
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        for (int i = 0; i < arr.length; i++) {
            total += arr[i];
            if (total == sum) {
                return i;
            }
            sum -= arr[i];
        }
        return -1;
    }

    public static int deleteDuplicatedElements(int[] array) {
        int len = array.length;
        int count = 1;
        int j = 0;//
        for (int i = 1; i < len; i++, j++) {
            if (array[i] != array[j]) {
                count++;
            }
        }
        return count;
    }

}
